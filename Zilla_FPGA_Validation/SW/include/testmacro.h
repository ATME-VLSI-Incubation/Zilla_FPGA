/// Copyright © 2021 Vivartan Technologies., All rights reserved.
// 
// All works published under Zilla_Gen_0 by the Vivartan Technologies. 
// is copyrighted by the Association and ownership of all right, title and interest
// in and to the works remains with Vivartan Technologies.
// 
// No works or documents published under Zilla_Gen_0 by Vivartan Technologies. may be reproduced,
// transmitted or copied without the express written permission of Vivartan Technologies.
// will be considered as a violations of Copyright Act and it may lead to legal action.

/*
**
*******************************************************************************
**
** Test macros:
**
** This headerfile provides the following macros
**     MUL_TEST_U8          - Macro for  uint8_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_U8_SPIKE    - Macro for  uint8_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_U8_C        - Macro for  uint8_t C multiplication with operands generated by mailbox
**     MUL_TEST_U8_SPIKE_C  - Macro for  uint8_t C multiplication with operands generated by random_xor()
**     MUL_TEST_U16         - Macro for uint16_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_U16_SPIKE   - Macro for uint16_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_U16_C       - Macro for uint16_t C multiplication with operands generated by mailbox
**     MUL_TEST_U16_SPIKE_C - Macro for uint16_t C multiplication with operands generated by random_xor()
**     MUL_TEST_U32         - Macro for uint32_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_U32_SPIKE   - Macro for uint32_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_U32_C       - Macro for uint32_t C multiplication with operands generated by mailbox
**     MUL_TEST_U32_SPIKE_C - Macro for uint32_t C multiplication with operands generated by random_xor()
**     MUL_TEST_S8          - Macro for   int8_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_S8_SPIKE    - Macro for   int8_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_S8_C        - Macro for   int8_t C multiplication with operands generated by mailbox
**     MUL_TEST_S8_SPIKE_C  - Macro for   int8_t C multiplication with operands generated by random_xor()
**     MUL_TEST_S16         - Macro for  int16_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_S16_SPIKE   - Macro for  int16_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_S16_C       - Macro for  int16_t C multiplication with operands generated by mailbox
**     MUL_TEST_S16_SPIKE_C - Macro for  int16_t C multiplication with operands generated by random_xor()
**     MUL_TEST_S32         - Macro for  int32_t assembly multiplication with operands generated by mailbox
**     MUL_TEST_S32_SPIKE   - Macro for  int32_t assembly multiplication with operands generated by random_xor()
**     MUL_TEST_S32_C       - Macro for  int32_t C multiplication with operands generated by mailbox
**     MUL_TEST_S32_SPIKE_C - Macro for  int32_t C multiplication with operands generated by random_xor()
**
** You need to include this header file in your test program if you are
** using the test macros
**
** Usage : #include "testmacro.h"
*******************************************************************************/


#ifndef TESTMACRO_H
#define TESTMACRO_H

#define MUL_ASM "mul %[z],%[x],%[y]\n\t"
#define LWU_ASM "lwu %[a],%[b]\n\t"
//#define MTR_ASM "lwu %[b],%[c]\n\t"
#define add_test " add %[z],%[x],%[y] \n\t "
#define and_test " and %[z],%[x],%[y] \n\t"
//asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; 
#define or_test  " or %[z],%[x],%[y] \n\t "
#define xor_test  " xor %[z],%[x],%[y] \n\t "
#define srl_test  " srl %[z],%[x],%[y] \n\t "
#define srlw_test " srlw %[z],%[x],%[y] \n\t "
#define sll_test  " sll %[z],%[x],%[y] \n\t "
#define sllw_test " sllw %[z],%[x],%[y] \n\t "
#define sra_test  " sra %[z],%[x],%[y] \n\t "
#define sraw_test  " sraw %[z],%[x],%[y] \n\t "


#define slti_test "slt %[z],%[x],%[y] \n\t "
#define sltiu_test "sltu %[z],%[x],%[y] \n\t "


#ifndef bit_32

//#include "type128.h"            //!< 128 width variable support  

#endif

#define TEST_THREE (150) //TEST_THREE : 15*5(testcount)*2(inputs)
#define MKSTR(s) #s
//////////////////////////////////////////////////////////////////
////            Add Immediate print                             //
//////////////////////////////////////////////////////////////////
#define print_test_results_I(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   Add %15lu  + %15lu  : E res = %15lu , A res = %10lu : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   Add %15lu  + %15lu  : E res = %15lu , A res = %10lu : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\
                


// For displaying results for uint8_t, uint16_t, uint32_t tests 
#define PRINT_RESULT_U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Multiply %s : %15u x %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Multiply %s : %15u x %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for int8_t int16_t, int32_t tests 
#define PRINT_RESULT_S(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Multiply %s : %15d x %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Multiply %s : %15d x %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,e_result, a_result);

// For displaying results for int8_t, int16_t, int32_t tests with uint8_t, uint16_t or uint32_t  
#define PRINT_RESULT_SU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Multiply %s : %15d x %15u  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Multiply %s : %15d x %15u  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying Addition results for uint8_t, uint16_t, uint32_t tests 
#define PRINT_RESULT_ADD_U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Add %s : %15u + %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Add %s : %15u + %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying Addition results for int8_t int16_t, int32_t tests 
#define PRINT_RESULT_ADD_S(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Add %s : %15d + %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Add %s : %15d + %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying Addition results for U&S 
#define PRINT_RESULT_ADD_SU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Add %s : %15u + %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Add %s : %15u + %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


// For displaying results for uint8_t, uint16_t, uint32_t tests - For subtraction 
#define PRINT_RESULT_SUB_U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Sub %s : %15X - %15X  : E-result = %15lX, A-result = %15lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Sub %s : %15X - %15X  : E-result = %15lX, A-result = %15lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for int8_t int16_t, int32_t tests - for subtraction 
#define PRINT_RESULT_SUB_S(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Sub %s : %15X - %15X  : E-result = %15lX, A-result = %15lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Sub %s : %15X - %15X  : E-result = %15lX, A-result = %15lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


// For displaying results for U&S 
#define PRINT_RESULT_SUB_SU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Sub %s : %15lX - %15lX  : E-result = %15lX, A-result = %15lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Sub %s : %15lX - %15lX  : E-result = %15lX, A-result = %15lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


// For displaying results for uint64_t tests 
#define PRINT_RESULT_U64(op1,op2,a_result_lo,e_result_lo,a_result_hi,e_result_hi,test_num,test_type) \
					 if((a_result_lo == e_result_lo) && (a_result_hi == e_result_hi)) \
					 	printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo); \
					 else \
						printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo);

// For displaying results for int64_t tests 
#define PRINT_RESULT_S64(op1,op2,a_result_lo,e_result_lo,a_result_hi,e_result_hi,test_num,test_type) \
					 if((a_result_lo == e_result_lo) && (a_result_hi == e_result_hi)) \
					 	printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo); \
					 else \
						printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo);


// For displaying results for int64_t uint64_t tests 
#define PRINT_RESULT_SU64(op1,op2,a_result_lo,e_result_lo,a_result_hi,e_result_hi,test_num,test_type) \
					 if((a_result_lo == e_result_lo) && (a_result_hi == e_result_hi)) \
					 	printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo); \
					 else \
						printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo);
///////////////////////////////////////////////////////////////////////////////////


#define PRINT_RESULT_SU64(op1,op2,a_result_lo,e_result_lo,a_result_hi,e_result_hi,test_num,test_type) \
					 if((a_result_lo == e_result_lo) && (a_result_hi == e_result_hi)) \
					 	printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo); \
					 else \
						printf("Test/> [%3d] Multiply %s: %016lX x %016lX : Erslt= %016lX%016lX, Arslt= %016lX%016lX : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result_hi, e_result_lo, a_result_hi, a_result_lo);


               
///////////////////////////////////////////////////// AND /////////////////////////////////////////////////////
/* For displaying results for uint8_t, uint16_t, uint32_t tests */
#define PRINT_RESULT_ANDU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] AND %s : %15u & %15u  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] AND %s : %15u & %15u  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

/* For displaying results for uint64_t tests */
#define PRINT_RESULT_AND64U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] AND %s : %15lu & %15lu  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] AND %s : %15lu & %15lu  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

//////////////////////////////////////////////////////////////////
////            AND Immediate print                             //
//////////////////////////////////////////////////////////////////
//
#define print_test_results_andi_I8(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   AND %15u  & %15d : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   AND %15u  & %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_andi_I16(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   AND %15u  & %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   AND %15u  & %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_andi_I32(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   AND %15u  & %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   AND %15u  & %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_andi_I64(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   AND %15lu  & %15ld  : E res = %15lu , A res = %10lu : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   AND %15lu  & %15ld  : E res = %15lu , A res = %10lu : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

///////////////////////////////////////////////////// OR /////////////////////////////////////////////////////
/* For displaying results for uint8_t, uint16_t, uint32_t tests */
#define PRINT_RESULT_ORU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] OR %s : %15u | %15u  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] OR %s : %15u | %15u  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

/* For displaying results for uint64_t tests */
#define PRINT_RESULT_OR64U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] OR %s : %15lu | %15lu  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] OR %s : %15lu | %15lu  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

//////////////////////////////////////////////////////////////////
////            OR Immediate print                             //
//////////////////////////////////////////////////////////////////
//
#define print_test_results_ori_I8(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   OR %15u  | %15d : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   OR %15u  | %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_ori_I16(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   OR %15u  | %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   OR %15u  | %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_ori_I32(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   OR %15u  | %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   OR %15u  | %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_ori_I64(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   OR %15lu  | %15ld  : E res = %15lu , A res = %10lu : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   OR %15lu  | %15ld  : E res = %15lu , A res = %10lu : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\



///////////////////////////////////////////////////// XOR /////////////////////////////////////////////////////
/* For displaying results for uint8_t, uint16_t, uint32_t tests */
#define PRINT_RESULT_XORU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] XOR %s : %15u ^ %15u  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] XOR %s : %15u ^ %15u  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

/* For displaying results for uint64_t tests */
#define PRINT_RESULT_XOR64U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] XOR %s : %15lu ^ %15lu  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
					 else \
						printf("Test/> [%3d] XOR %s : %15lu ^ %15lu  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

//////////////////////////////////////////////////////////////////
////            XOR Immediate print                             //
//////////////////////////////////////////////////////////////////
//
#define print_test_results_xori_I8(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   XOR %15u  ^ %15d : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   XOR %15u  ^ %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_xori_I16(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   XOR %15u  ^ %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   XOR %15u  ^ %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_xori_I32(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   XOR %15u  ^ %15d  : E res = %15u , A res = %10u : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   XOR %15u  ^ %15d  : E res = %15u , A res = %10u : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

#define print_test_results_xori_I64(testnumber, op1, op2, result, exp_result)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   XOR %15lu  ^ %15ld  : E res = %15lu , A res = %10lu : Status = [PASS]\n", testnumber,op1,op2,result,exp_result);\
                else \
                printf ("Test imm [%3d]   XOR %15lu  ^ %15ld  : E res = %15lu , A res = %10lu : Status = [FAIL]\n", testnumber,op1,op2,result,exp_result);\

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///Division//

#define DIV_PRINT_RESULT_UU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15u / %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15u / %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for uint8_t, uint16_t or uint32_t  tests with  int8_t, int16_t, int32_t
#define DIV_PRINT_RESULT_US(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
                        printf("Test/> [%3d] Division %s : %15u / %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15u / %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,e_result, a_result);

// For displaying results for int8_t, int16_t, int32_t tests with uint8_t, uint16_t or uint32_t  
#define DIV_PRINT_RESULT_SU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15d / %15u  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15d / %15u  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for both operand signed 
#define DIV_PRINT_RESULT_SS(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15d / %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15d / %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// 64 bit division print macro : op1 unsigned and op2 unsigned 
#define DIV_PRINT_RESULT_UU64(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15lu / %15lu  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15lu / %15lu  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// 64 bit division print macro : op1 unsigned and op2 signed 
#define DIV_PRINT_RESULT_US64(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
                        printf("Test/> [%3d] Division %s : %15lu / %15ld  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15lu / %15ld  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,e_result, a_result);


// 64 bit division print macro : op1 signed and op2 unsigned 
#define DIV_PRINT_RESULT_SU64(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15ld / %15lu  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15ld / %15lu  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// 64 bit division print macro : op1 signed and op2 signed 
#define DIV_PRINT_RESULT_SS64(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Division %s : %15ld / %15ld  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Division %s : %15ld / %15ld  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);



///////////////////////////////////////////////////////////
//
////////////////// Remainder Print Macro /////////////////
//
////////////////////////////////////////////////////////

// For displaying results for uint8_t, uint16_t, uint32_t tests 
#define REM_PRINT_RESULT_UU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Remainder %s : %15u %% %15u  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Remainder %s : %15u %% %15u  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for uint8_t, uint16_t or uint32_t  tests with  int8_t, int16_t, int32_t
#define REM_PRINT_RESULT_US(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
                        printf("Test/> [%3d] Remainder %s : %15u %% %15d  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Remainder %s : %15u %% %15d  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,e_result, a_result);

// For displaying results for int8_t, int16_t, int32_t tests with uint8_t, uint16_t or uint32_t  
#define REM_PRINT_RESULT_SU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Remainder %s : %15d %% %15u  : E-result = %15d, A-result = %15d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Remainder %s : %15d %% %15u  : E-result = %15d, A-result = %15d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for int8_t int16_t, int32_t tests 
#define REM_PRINT_RESULT_SS(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Remainder %s : %15d %% %15d  : E-result = %15d, A-result = %15d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Remainder %s : %15d %% %15d  : E-result = %15d, A-result = %15d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


/* shift right logical print macros */

#define SRL_PRINT_RESULT_U(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Logical Right Shift %s : %15lu >> %5u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Logical Right Shift %s : %15lu >> %5u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

#define SRL_PRINT_RESULT_S(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Logical Right Shift %s : %15ld >> %5u  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Logical Right Shift %s : %15ld >> %5u  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


#define SRL_PRINT_RESULT_S16(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Logical Right Shift %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2,(int16_t)e_result, (int16_t)a_result); \
					 else \
						printf("Test/> [%3d] Logical Right Shift %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,(int16_t)e_result,(int16_t)a_result);

#define SRL_PRINT_RESULT_S8(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Logical Right Shift %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2,(int8_t)e_result, (int8_t)a_result); \
					 else \
						printf("Test/> [%3d] Logical Right Shift %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2,(int8_t)e_result,(int8_t)a_result);



////////////////////////////////////////////Shift Logical Right immediate print macro ///////////////////////////////////////////////////

#define SRLI_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SRLI  %s  %18lu  >> %5u  : E res = %18lu , A res = %18lu : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SRLI  %s  %18lu  >> %5u  : E res = %18lu , A res = %18lu : Status = [FAIL]\n", testnumber,MKSTR(data_type) ,op1,op2,exp_result , result);\


#define SRLIW_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SRLIW %s  %15u  >> %5u  : E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SRLIW %s  %15u  >> %5u  : E res = %15u,  A res = %15u: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\



#define SRLI_PRINT_TEST_RESULTS_S(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SRLI  %s  %18ld  >> %5u  : E res = %18lu , A res = %18lu : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SRLI  %s  %18ld  >> %5u  : E res = %18lu , A res = %18lu : Status = [FAIL]\n", testnumber,MKSTR(data_type) ,op1,op2,exp_result , result);\


#define SRLIW_PRINT_TEST_RESULTS_S(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SRLIW %s  %15d  >> %5u  : E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SRLIW %s  %15d  >> %5u  : E res = %15u,  A res = %15u: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
/////            Set less than Print                 /////////////
//////////////////////////////////////////////////////////////////
// For displaying results for uint8_t, uint16_t, uint32_t,uint64_t  tests 
#define SLTU_PRINT_RESULT_UU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Set less than %s : %15u < %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] Set less than %s : %15u < %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for int8_t int16_t, int32_t,int64_t tests 
#define SLT_PRINT_RESULT_SS(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] Set less than %s : %15d < %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
				   	 else \
						printf("Test/> [%3d] Set less than %s : %15d < %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);
						

////////////////////////////////////////////Set less than immediate print macro ///////////////////////////////////////////////////

#define SLTIU_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLTIU %s  %15lu  < %15lu  : E res = %15lu , A res = %15lu : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLTIU %s  %15lu  < %15lu  : E res = %15lu,  A res = %15lu: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\




#define SLTI_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLTI %s  %15ld  <  %15ld  : E res = %15ld , A res = %15ld : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLTI %s  %15ld  < %15ld  : E res = %15ld,  A res = %15ld: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\



//////////////////////////////////////////////////////////////////
/////            Left shift Print                    /////////////
//////////////////////////////////////////////////////////////////
// For displaying results for uint8_t, uint16_t, uint32_t tests 
#define SLL_PRINT_RESULT_UU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] left shift %s : %15u << %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] left shift %s : %15u << %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

// For displaying results for int8_t int16_t, int32_t tests 
#define SLL_PRINT_RESULT_SS(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] left shift %s : %15d << %15d  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
				   	 else \
						printf("Test/> [%3d] left shift %s : %15d << %15d  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);
						

#define SLLW_PRINT_RESULT_UU(op1,op2,a_result,e_result,test_num,test_type) \
					 if(a_result == e_result) \
					 	printf("Test/> [%3d] left shift %s : %15u << %15u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
					 else \
						printf("Test/> [%3d] left shift %s : %15u << %15u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);



////////////////////////////////////////////Shift Logical left immediate print macro ///////////////////////////////////////////////////

#define SLLI_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLLI  %s  %18lu  >> %5u  : E res = %18lu , A res = %18lu : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLLI  %s  %18lu  >> %5u  : E res = %18lu , A res = %18lu : Status = [FAIL]\n", testnumber,MKSTR(data_type) ,op1,op2,exp_result , result);\


#define SLLIW_PRINT_TEST_RESULTS(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLLIW %s  %15u  >> %5u  : E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLLIW %s  %15u  >> %5u  : E res = %15u,  A res = %15u: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\



#define SLLI_PRINT_TEST_RESULTS_S(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLLI  %s  %18ld  >> %5u  : E res = %18lu , A res = %18lu : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLLI  %s  %18ld  >> %5u  : E res = %18lu , A res = %18lu : Status = [FAIL]\n", testnumber,MKSTR(data_type) ,op1,op2,exp_result , result);\


#define SLLIW_PRINT_TEST_RESULTS_S(testnumber, op1, op2, result, exp_result , data_type)\
            if(result == exp_result)\
                printf ("Test imm [%3d]   SLLIW %s  %15d  >> %5u  : E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result);\
                else \
                printf ("Test imm [%3d]   SLLIW %s  %15d  >> %5u  : E res = %15u,  A res = %15u: Status = [FAIL]\n", testnumber,MKSTR(data_type),op1,op2,exp_result, result );\


//////////////////////////////      SHIFT RIGHT ARITHMETIC OPERATION       //////////////////////////////////////////////////


/**************************************************************************************************************                                                                                            ////////
*********                               PRINT RESULT for SRA/SRAW Instructions                       **********
*********                                                                                            **********
**************************************************************************************************************/

#define SRAW_PRINT_RESULT_U(op1,op2,a_result,e_result,test_num,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%0d] SRAW %s : %10u >> %10u  : A-result = %10u, E-result = %10u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
	else \
	    printf("Test/> [%0d] SRAW %s : %10u >> %10u  : A-result = %10u, E-result = %10u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);


#define SRAW_PRINT_RESULT_S(op1,op2,a_result,e_result,test_num,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%0d] SRAW %s : %10d >> %10u  : A-result = %10d, E-result = %10d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
	else \
	    printf("Test/> [%0d] SRAW %s : %10d >> %10u  : A-result = %10d, E-result = %10d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);

#define SRA_PRINT_RESULT_U(op1,op2,a_result,e_result,test_num,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%0d] SRA %s : %10lu >> %10u  : A-result = %10lu, E-result = %10lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
	else \
	    printf("Test/> [%0d] SRA %s : %10lu >> %10u  : A-result = %10lu, E-result = %10lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);


#define SRA_PRINT_RESULT_S(op1,op2,a_result,e_result,test_num,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%0d] SRA %s : %10ld >> %10u  : A-result = %10ld, E-result = %10ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result); \
	else \
	    printf("Test/> [%0d] SRA %s : %10ld >> %10d  : A-result = %10ld, E-result = %10ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, a_result, e_result);


/**********************************************************************************************************************
 ***************                    PRINT RESULT for SRAI/SRAIW Instructions                   ************************
 ***************                                                                               ************************
 ************************************************************************************************************************/

#define SRAIW_PRINT_RESULT_S(test_num,op1,op2,a_result,e_result,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%3d] Imm SRAW %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
    else \
	    printf("Test/> [%3d] Imm SRAW %s : %15d >> %5u  : E-result = %15d, A-result = %15d : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

#define SRAIW_PRINT_RESULT_U(test_num,op1,op2,a_result,e_result,test_type) \
    if(a_result == e_result) \
		printf("Test/> [%3d] Imm SRAW %s : %15u >> %5u  : E-result = %15u, A-result = %15u : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
    else \
		printf("Test/> [%3d] Imm SRAW %s : %15u >> %5u  : E-result = %15u, A-result = %15u : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

#define SRAI_PRINT_RESULT_S(test_num,op1,op2,a_result,e_result,test_type) \
    if(a_result == e_result) \
	    printf("Test/> [%3d] Imm SRA %s : %15ld >> %5u  : E-result = %15ld, A-result = %15ld : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
    else \
	    printf("Test/> [%3d] Imm SRA %s : %15ld >> %5u  : E-result = %15ld, A-result = %15ld : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);

#define SRAI_PRINT_RESULT_U(test_num,op1,op2,a_result,e_result,test_type) \
    if(a_result == e_result) \
		printf("Test/> [%3d] Imm SRA %s : %15lu >> %5u  : E-result = %15lu, A-result = %15lu : Status = [PASS]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result); \
    else \
		printf("Test/> [%3d] Imm SRA %s : %15lu >> %5u  : E-result = %15lu, A-result = %15lu : Status = [FAIL]\n", test_num, MKSTR(test_type), op1, op2, e_result, a_result);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////
//
////////////////Macro to print load and store ////////////////
//
//////////////////////////////////////////////////////////////
//macro print load and store unsigned
#define PRINT_LOAD_STORE_TEST_RESULT_IU(testnumber, op1, op2, op3 , result, exp_result)\
            if((result == exp_result) && (result == op1 ) ) \
                printf ("Test  [%3d]   Store = %15u to   [%#010X  + 12'd%10d ] load: E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,op1,op2,op3,exp_result,result);\
                else \
                printf ("Test  [%3d]   Store = %15u to   [%#010X  + 12'd%10d ] load: E res = %15u , A res = %15u : Status = [FAIL]\n", testnumber,op1,op2,op3,exp_result ,result);\
                
//macro print load and store signed 
#define PRINT_LOAD_STORE_TEST_RESULT_IS(testnumber, op1, op2, op3 , result, exp_result)\
            if( (result == exp_result) && (result == op1 )) \
                printf ("Test  [%3d]   Store = %15ld to   [%#010X  + 12'd%10ld ] load: E res = %15ld , A res = %15ld : Status = [PASS]\n", testnumber,op1,op2,op3,exp_result,result);\
                else \
                printf ("Test  [%3d]   Store = %15ld to   [%#010X  + 12'd%10ld ] load: E res = %15ld , A res = %15ld : Status = [FAIL]\n", testnumber,op1,op2,op3,exp_result ,result);\

////////////////////////////////////////////////////////
//
/////////////////////macro to print LUI ///////////////
//
///////////////////////////////////////////////////////

//macro print LUI
#define PRINT_LUI_TEST_RESULT_I(testnumber, imm , result, exp_result)\
                if(result == exp_result ) \
                printf ("Test  [%3d]   LUI = %#10X   E res =0x %016lX , A res =0x %016lX : Status = [PASS]\n", testnumber,imm,exp_result,result);\
                else \
                printf ("Test  [%3d]   LUI = %#10X   E res =0x %016lX , A res =0x %016lX : Status = [FAIL]\n", testnumber,imm,exp_result ,result);\



////////////////////////////////////////////////////////////////////////
////////////           Branch and jump display            //////////////
///////////////////////////////////////////////////////////////////////

#define PRINT_RESULT_SORT(rslt_tb,rslt_full)\
 for(int i=0;i<10;i++)\
   {    if(rslt_tb[i] == rslt_full[i])\
       printf("Test/>   Sort : E-result = %15ld, A-result = %15ld : Status = [PASS] \n", rslt_full[i], rslt_tb[i]);\
     else\
   	   printf("Test/>   Sort : E-result = %15ld, A-result = %15ld : Status = [FAIL] \n", rslt_full[i], rslt_tb[i]);\
   }

        
#define PRINT_RESULT_SEARCH(rslt_tb,rslt_full)\
if(rslt_tb==rslt_full)\
    printf("Test/>   Search : E-result = %15d, A-result = %15d : Status = [PASS] \n", rslt_full, rslt_tb);\
 else\
    printf("Test/>   Search : E-result = %15d, A-result = %15d : Status = [FAIL] \n", rslt_full, rslt_tb);\




//********************************** Multiplication Test uint8_t MACROs *******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8_(&op1, &op2, &rslt_full);

// Macro for MUL test without spike (C) 
#define MUL_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 * op2;



//********************************** Multiplication Test int8_t MACROs *******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          _MUL_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
					  int16_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  _MUL_TEST_S8_(&op1, &op2, &rslt_full);

// Macro for MUL test without spike (C) 
#define MUL_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


//********************************** Multiplication Test uint16_t MACROs *******************************************

// Note: 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _MUL_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U16_(&op1, &op2, &rslt_full);


// Macro for MUL test without spike (C) 
#define MUL_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (C) 
#define MUL_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 * op2;


//********************************** Multiplication Test int16_t MACROs *******************************************

// Note: 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          _MUL_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S16_(&op1, &op2, &rslt_full);


// Macro for MUL test without spike (C) 
#define MUL_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 * op2;


//********************************** Multiplication Test uint32_t MACROs *******************************************

// Note: 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _MUL_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U32_(&op1, &op2, &rslt_full);


// Macro for MUL test without spike (C) 
#define MUL_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 * op2;


//********************************** Multiplication Test int32_t MACROs *******************************************

// Note: 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _MUL_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S32_(&op1, &op2, &rslt_full);


// Macro for MUL test without spike (C) 
#define MUL_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 * op2;

//********************************** Multiplication Test uint8_t and uint16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_U816_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_U816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 * op2;


//********************************** Multiplication Test uint8_t and uint32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C) 
#define MUL_TEST_U832EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_U832EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 * op2;



//**************************************************Part3****************************************************

#define RAND_ARR_STORE_C(mb)\
					  int64_t arrzzz[TEST_THREE];\
					  int64_t *p=arrzzz;\
					  for (int i = 0;i<TEST_THREE;i=i+2)\
					  {arrzzz[i] = (int64_t)generate_random_num(mb);\
					  arrzzz[i+1] = (int64_t)generate_random_num(mb);\
					  }\
					  

//********************************** Multiplication Test uint8_t and uint16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_U816EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
// Macro for MUL test with spike (C) 
#define MUL_TEST_U816EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 * op2;\
					  //z_printf("hello world");\
					  

//********************************** Multiplication Test uint8_t and uint32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  

#define MUL_TEST_U832_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
					  op2 = (uint32_t)(*p); \
					  p++;\
					  rslt_full = (uint64_t)op1 * op2;\
                               		  actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

					  //rslt_full = (uint64_t)(op1 * op2); \op2 = (uint32_t)(*p); \
                                          //asm volatile (LWU_ASM : [a] "=r" (op2) : [b] "m" (*p)); \
                                          //asm volatile (MTR_ASM : [b] "=r" (opx) : [c] "m" (*p)); \	
                                          //asm volatile (LWU_ASM : [a] "=r" (op2) : [b] "m" (*p)); \		
					  //asm volatile (MUL_ASM : [z] "=r" (rslt_full) : [x] "r" (op1), [y] "r" (op2)); \

		  
// Macro for MUL test with spike (C) 
#define MUL_TEST_U832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
					  op2 = (uint32_t)data[(tn-1)*3 + 1]; \
					  rslt_full = (uint64_t)op1 * op2;\
					  rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \                 
                                                        
    
					  //for (int i=0;i<k;i++)\
					  //rslt_full = op1 * op2;\
					  //asm volatile (MUL_ASM : [z] "=r" (rslt_full) : [x] "r" (op1), [y] "r" (op2)); \
					  //{PRINT_RESULT_U(op1_8u,op2_32u,result_64u_tb,result_64u_full,testnumber,uint64_t);\
					  //}                                          
					  //op2 = (uint32_t)data[(tn-1)*3 + 1]; \
					  //asm volatile (LWU_ASM : [a] "=r" (op2) : [b] "m" (*p)); \



//********************************** Multiplication Test uint16_t and uint32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_U1632_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1; \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (uint16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
// Macro for MUL test with spike (C) 
#define MUL_TEST_U1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;  \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1 ]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2 ]; \
                                          rslt_full = (uint64_t)op1 * op2;\
					  

//********************************** Multiplication Test int8_t and int16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S816_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int16_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


//********************************** Multiplication Test int8_t and int32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S832_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


//********************************** Multiplication Test int16_t and int32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S1632_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


//********************************** Multiplication Test int8_t and uint8_t MACROs *******************************************

// Note: 8-bit operand and 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S8U8_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint8_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


//********************************** Multiplication Test int16_t and uint16_t MACROs *******************************************

// Note: 16-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S16U16_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;



//********************************** Multiplication Test int32_t and uint32_t MACROs *******************************************

// Note: 32-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S32U32_C(mb,op1,op2,rslt_full,tn) \
					  int32_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (int32_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1*op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S32U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int32_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1*op2;


//********************************** Multiplication Test int8_t and uint16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S8U16_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


//********************************** Multiplication Test int8_t and uint32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S8U32_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1*op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S8U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1*op2;



//********************************** Multiplication Test int16_t and uint32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S16U32_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1*op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S16U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1*op2;


//********************************** Multiplication Test int16_t and uint8_t MACROs *******************************************

// Note: 16-bit operand and 8-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S16U8_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint8_t)(*p); \
					  p++;\
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S16U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


//********************************** Multiplication Test int32_t and uint8_t MACROs *******************************************

// Note: 32-bit operand and 8-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S32U8_C(mb,op1,op2,rslt_full,tn) \
					  int32_t op1;\
					  uint8_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (int32_t)(*p); \
					  p++;\
                                          op2 = (uint8_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S32U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int32_t op1;\
					  uint8_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1*op2;


//********************************** Multiplication Test int32_t and uint16_t MACROs *******************************************

// Note: 32-bit operand and 16-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (C)  
#define MUL_TEST_S32U16_C(mb,op1,op2,rslt_full,tn) \
					  int32_t op1;\
					  uint16_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = (int32_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for MUL test with spike (C) 
#define MUL_TEST_S32U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int32_t op1;\
					  uint16_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;




//*****************************************************Part4************************************************
					  
#define RAND_ARR_STORE(mb,tn,t,n)\
					  int64_t arra[TEST_FOUR];\
					  int64_t *pa=arra;\
					  for (int i = 0;i<TEST_FOUR;i=i+2)\
					  {arra[i] = (int64_t)generate_random_num(mb);\
					  arra[i+1] = (int64_t)generate_random_num(mb);\
					  }\
					  
					  
//********************************** Multiplication Test uint8_t and uint16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U816(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint16_t op2;\
                                          uint32_t rslt_full; \
                                          op1 = (uint8_t)(*pa); \
					  pa ++;\
                                          op2 = (uint16_t)(*pa); \
					  pa++;\
                                          _MUL_TEST_U816_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U816_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint16_t op2;\
                                          uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U816_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t and uint32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U832(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint32_t op2;\
                                          uint64_t rslt_full; \
                                          op1 = (uint8_t)(*pa); \
					  pa ++;\
                                          op2 = (uint32_t)(*pa); \
					  pa++;\
                                          _MUL_TEST_U832_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U832_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint32_t op2;\
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U832_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint16_t and uint32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U1632(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  uint32_t op2;\
                                          uint64_t rslt_full; \
                                          op1 = (uint16_t)(*pa); \
					  pa++;\
                                          op2 = (uint32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_U1632_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U1632_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  uint32_t op2;\
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U1632_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int8_t and int16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S816(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int16_t op2;\
                                          int32_t rslt_full; \
                                          op1 = (int8_t)(*pa); \
					  pa++;\
                                          op2 = (int16_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S816_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S816_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int16_t op2;\
                                          int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S816_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int8_t and int32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S832(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int32_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int8_t)(*pa); \
					  pa++;\
                                          op2 = (int32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S832_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S832_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int32_t op2;\
                                          int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S832_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int16_t and int32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S1632(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  int32_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int16_t)(*pa); \
					  pa++;\
                                          op2 = (int32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S1632_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S1632_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  int32_t op2;\
                                          int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S1632_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int8_t and uint8_t MACROs *******************************************

// Note: 8-bit operand and 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S8U8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint8_t op2;\
                                          int16_t rslt_full; \
                                          op1 = (int8_t)(*pa); \
					  pa++;\
                                          op2 = (uint8_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S8U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S8U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint8_t op2;\
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S8U8_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int16_t and uint16_t MACROs *******************************************

// Note: 16-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S16U16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  uint16_t op2;\
                                          int32_t rslt_full; \
                                          op1 = (int16_t)(*pa); \
					  pa++;\
                                          op2 = (uint16_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S16U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S16U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  uint16_t op2;\
                                          int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S16U16_(&op1, &op2, &rslt_full);

                          
//********************************** Multiplication Test int32_t and uint32_t MACROs *******************************************

// Note: 32-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S32U32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int32_t)(*pa); \
					  pa++;\
                                          op2 = (uint32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S32U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S32U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S32U32_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int8_t and uint16_t MACROs *******************************************

// Note: 8-bit operand and 16-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S8U16(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint16_t op2;\
                                          int32_t rslt_full; \
                                          op1 = (int8_t)(*pa); \
					  pa++;\
                                          op2 = (uint16_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint16_t op2;\
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S8U16_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int8_t and uint32_t MACROs *******************************************

// Note: 8-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S8U32(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int8_t)(*pa); \
					  pa++;\
                                          op2 = (uint32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S8U32_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int16_t and uint32_t MACROs *******************************************

// Note: 16-bit operand and 32-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S16U32(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int16_t)(*pa); \
					  pa++;\
                                          op2 = (uint32_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  uint32_t op2;\
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S16U32_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int16_t and uint8_t MACROs *******************************************

// Note: 16-bit operand and 8-bit operand multiplication will create result of 32-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S16U8(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  uint8_t op2;\
                                          int32_t rslt_full; \
                                          op1 = (int16_t)(*pa); \
					  pa++;\
                                          op2 = (uint8_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S16U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S16U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  uint8_t op2;\
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S16U8_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int32_t and uint8_t MACROs *******************************************

// Note: 32-bit operand and 8-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S32U8(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1; \
					  uint8_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int32_t)(*pa); \
					  pa++;\
                                          op2 = (uint8_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S32U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S32U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
					  uint8_t op2;\
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S32U8_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test int32_t and uint16_t MACROs *******************************************

// Note: 32-bit operand and 16-bit operand multiplication will create result of 64-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S32U16(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1; \
					  uint16_t op2;\
                                          int64_t rslt_full; \
                                          op1 = (int32_t)(*pa); \
					  pa++;\
                                          op2 = (uint16_t)(*pa); \
				 	  pa++;\
                                          _MUL_TEST_S32U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S32U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
					  uint16_t op2;\
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_S32U16_(&op1, &op2, &rslt_full);



//////////////////////////////////////  Part5  /////////////////////////

//////////////////////////////////////// Multiplication Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_SRC2_EQ_DEST*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _MUL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8ZEROSRC1_(&op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _MUL_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8ZEROSRC2_(&op1, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _MUL_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8ZEROSRC12_(&rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Multiplication Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand multiplication will create result of 16-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _MUL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _MUL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);



//////////////////////////////////////////////// Part 6 ////////////////////////////////////////////


/* Note: Max of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXU816_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT8_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXU816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 * op2;\
					  

/*********************************** Multiplication Test int8_t and uint8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand multiplication will create result of 16-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS8U8_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int16_t and uint8_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 8-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS16U8_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS16U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int8_t and uint16_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS8U16_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int16_t and uint16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS16U16_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int8_t and int16_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS816_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = INT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int8_t and int8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand multiplication will create result of 16-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = INT8_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int16_t and int16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = INT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int32_t and int32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT32_MAX; \
                                          op2 = INT32_MAX; \
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


/*********************************** Multiplication Test uint8_t and uint8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand multiplication will create result of 16-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test uint16_t and uint16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test uint32_t and uint32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (uint64_t)op1 * op2;


/*********************************** Multiplication Test int8_t and int32_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 16-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS832_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = INT32_MAX; \
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


/*********************************** Multiplication Test int16_t and int32_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MAXS1632_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = INT32_MAX; \
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MAXS1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;




////////////////////////////////////////////////////////////////////////////////////////////////

/* Note: Min of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINU816_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINU816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 * op2;\
					  //z_printf("hello world");\
					  



/*********************************** Multiplication Test int8_t and uint8_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 8-bit operand multiplication will create result of 16-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS8U8_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int i;\
					  op1 = INT8_MIN; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;




/*********************************** Multiplication Test int16_t and uint8_t MACROs ********************************************/

/* Note: Min of 16-bit operand and 8-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS16U8_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS16U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;



/*********************************** Multiplication Test int8_t and uint16_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS8U16_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int8_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;




/*********************************** Multiplication Test int16_t and uint16_t MACROs ********************************************/

/* Note: Min of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS16U16_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
					  int16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int8_t and int16_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS816_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = INT16_MIN; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int8_t and int8_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 8-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = INT8_MIN; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int16_t and int16_t MACROs ********************************************/

/* Note: Min of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = INT16_MIN; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test int32_t and int32_t MACROs ********************************************/

/* Note: Min of 32-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT32_MIN; \
                                          op2 = INT32_MIN; \
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


/*********************************** Multiplication Test int8_t and int32_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS832_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = INT32_MIN; \
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


/*********************************** Multiplication Test int16_t and int32_t MACROs ********************************************/

/* Note: Min of 16-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINS1632_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = INT32_MIN; \
				          rslt_full = (int64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINS1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (int64_t)op1 * op2;


/*********************************** Multiplication Test uint8_t and uint8_t MACROs ********************************************/

/* Note: Min of 8-bit operand and 8-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test uint16_t and uint16_t MACROs ********************************************/

/* Note: Min of 16-bit operand and 16-bit operand multiplication will create result of 32-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 * op2;


/*********************************** Multiplication Test uint32_t and uint32_t MACROs ********************************************/

/* Note: Min of 32-bit operand and 32-bit operand multiplication will create result of 64-bit */

/* Macro for MUL test without spike (C)  */
#define MUL_TEST_MINU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = 0; \
                                          op2 = 0; \
				          rslt_full = (uint64_t)op1 * op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_MINU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = (uint64_t)op1 * op2;


/*********************************** Multiplication 64 MACROs ********************************************/


//********************************** Multiplication Test uint64_t MACROs *******************************************

// Note: 64-bit operand multiplication will create result of 128-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi);

// Macro for MUL test without spike (C) 
#define MUL_TEST_U64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
					  uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (C) 
#define MUL_TEST_U64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
					  uint128_t rslt_128 = (uint128_t)op1 * op2; \
					  rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64);

//********************************** Multiplication Test int64_t MACROs *******************************************

// Note: 64-bit operand multiplication will create result of 128-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_S64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_S64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi);

// Macro for MUL test without spike (C) 
#define MUL_TEST_S64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
					  int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
                                          actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (C) 
#define MUL_TEST_S64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
					  int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64);


//********************************** Multiplication Test int64_t and uint64_t MACROs *******************************************

// Note: 64-bit operand multiplication will create result of 128-bit 

// Macro for MUL test without spike (assembly) 
#define MUL_TEST_SU64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (assembly) 
#define MUL_TEST_SU64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi);

// Macro for MUL test without spike (C) 
#define MUL_TEST_SU64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
                                          actual_result[(tn-1)*4 + 3] = rslt_hi;

// Macro for MUL test with spike (C) 
#define MUL_TEST_SU64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64);


/**************************************************Part3****************************************************/

/*********************************** Multiplication Test uint64_t and uint8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_U64U8_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint8_t) generate_random_num(mb); \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_U64U8_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64);


/*********************************** Multiplication Test uint64_t and uint16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_U64U16_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint16_t) generate_random_num(mb); \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_U64U16_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \


/*********************************** Multiplication Test uint64_t and uint32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_U64U32_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint32_t) generate_random_num(mb); \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_U64U32_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          uint128_t rslt_128 = (uint128_t)op1 * op2; \
                                          rslt_lo = (uint64_t) rslt_128; \
					  rslt_hi = (uint64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int64_t and int8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S64S8_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S64S8_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int64_t and int16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S64S16_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S64S16_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int64_t and int32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S64S32_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S64S32_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int8_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S8U64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S8U64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int8_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
					  

/*********************************** Multiplication Test int16_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S16U64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S16U64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int16_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int32_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S32U64_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S32U64_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int32_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \


/*********************************** Multiplication Test int64_t and uint8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S64U8_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S64U8_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
					  

/*********************************** Multiplication Test int64_t and uint16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64U16_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64U16_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \

					 
/*********************************** Multiplication Test int64_t and uint32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (C) */
#define MUL_TEST_S64U32_C(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (C) */
#define MUL_TEST_S64U32_SPIKE_C(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          int128_t rslt_128 = (int128_t)op1 * op2; \
                                          rslt_lo = (int64_t) rslt_128; \
					  rslt_hi = (int64_t) (rslt_128>>64); \
					 


/*****************************************************Part4************************************************/

/*********************************** Multiplication Test uint64_t and uint8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint8_t) generate_random_num(mb); \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t and uint16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint16_t) generate_random_num(mb); \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t and uint32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint32_t) generate_random_num(mb); \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test int64_t and int8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64S8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64S8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\


/*********************************** Multiplication Test int64_t and int16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64S16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64S16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test int64_t and int32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64S32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64S32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test int8_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S8U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S8U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int8_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test int16_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S16U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S16U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int16_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\					  


/*********************************** Multiplication Test int32_t and uint64_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S32U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S32U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int32_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test int64_t and uint8_t MACROs ********************************************/

/* Note: 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test int64_t and uint16_t MACROs ********************************************/

/* Note: 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                        _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test int64_t and uint32_t MACROs ********************************************/

/* Note: 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_S64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_S64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\

					 
/*****************************************************Part5************************************************/

/*********************************** Multiplication Test uint64_t TEST_RR_SRC1_EQ_DEST MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64SRC1_EQ_DEST(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64SRC1_EQ_DEST_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64SRC1_EQ_DEST_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64SRC1_EQ_DEST_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_SRC2_EQ_DEST MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64SRC2_EQ_DEST(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64SRC2_EQ_DEST_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64SRC2_EQ_DEST_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64SRC2_EQ_DEST_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_SRC12_EQ_DEST MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64SRC12_EQ_DEST(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = op1; \
                                          _MUL_TEST_U64SRC12_EQ_DEST_(&op1, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64SRC12_EQ_DEST_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64SRC12_EQ_DEST_(&op1, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_ZEROSRC1 MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64ZEROSRC1(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64ZEROSRC1_(&op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64ZEROSRC1_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64ZEROSRC1_(&op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_ZEROSRC2 MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64ZEROSRC2(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = 0; \
                                          _MUL_TEST_U64ZEROSRC2_(&op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64ZEROSRC2_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64ZEROSRC2_(&op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_ZEROSRC12 MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64ZEROSRC12(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          _MUL_TEST_U64ZEROSRC12_(&rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64ZEROSRC12_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64ZEROSRC12_(&rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_ZERODEST MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64ZERODEST(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64ZERODEST_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64ZERODEST_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64ZERODEST_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_DEST_BYPASS MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64DEST_BYPASS(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64DEST_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64DEST_BYPASS_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64DEST_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_SRC12_BYPASS MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64SRC12_BYPASS(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64SRC12_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64SRC12_BYPASS_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64SRC12_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test uint64_t TEST_RR_SRC21_BYPASS MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_U64SRC21_BYPASS(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = (uint64_t) generate_random_num(mb); \
                                          op2 = (uint64_t) generate_random_num(mb); \
                                          _MUL_TEST_U64SRC21_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_U64SRC21_BYPASS_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64SRC21_BYPASS_(&op1, &op2, &rslt_lo, &rslt_hi);


/*****************************************************Part6************************************************/


/*********************************** Multiplication Test max of uint64_t MACROs ********************************************/

/* Note: Max of 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXU64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXU64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of int64_t MACROs ********************************************/

/* Note: Max of 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = INT64_MAX; \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of int64_t and uint64_t MACROs ********************************************/

/* Note: Max of 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXSU64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = UINT64_MAX; \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXSU64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of uint64_t and uint8_t MACROs ********************************************/

/* Note: Max of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXU64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT8_MAX; \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXU64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of uint64_t and uint16_t MACROs ********************************************/

/* Note: Max of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXU64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT16_MAX; \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXU64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of uint64_t and uint32_t MACROs ********************************************/

/* Note: Max of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXU64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT32_MAX; \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXU64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of int64_t and int8_t MACROs ********************************************/

/* Note: Max of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64S8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = INT8_MAX; \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64S8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\


/*********************************** Multiplication Test max of int64_t and int16_t MACROs ********************************************/

/* Note: Max of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64S16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = INT16_MAX; \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64S16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of int64_t and int32_t MACROs ********************************************/

/* Note: Max of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64S32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = INT32_MAX; \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64S32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test max of int8_t and uint64_t MACROs ********************************************/

/* Note: Max of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS8U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT8_MAX; \
                                          op2 = UINT64_MAX; \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS8U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int8_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					 

/*********************************** Multiplication Test max of int16_t and uint64_t MACROs ********************************************/

/* Note: Max of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS16U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT16_MAX; \
                                          op2 = UINT64_MAX; \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS16U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int16_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\					  


/*********************************** Multiplication Test max of int32_t and uint64_t MACROs ********************************************/

/* Note: Max of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS32U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT32_MAX; \
                                          op2 = UINT64_MAX; \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS32U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int32_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test max of int64_t and uint8_t MACROs ********************************************/

/* Note: Max of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = UINT8_MAX; \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test max of int64_t and uint16_t MACROs ********************************************/

/* Note: Max of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = UINT16_MAX; \
                                          _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                        _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  


/*********************************** Multiplication Test max of int64_t and uint32_t MACROs ********************************************/

/* Note: Max of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MAXS64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MAX; \
                                          op2 = UINT32_MAX; \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MAXS64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\
					 
					  
/////////////////////////////////////////////////////////////////////////////////

/*********************************** Multiplication Test min of uint64_t MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINU64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINU64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of int64_t MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = INT64_MIN; \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of int64_t and uint64_t MACROs ********************************************/

/* Note: 64-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINSU64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINSU64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_SU64_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of uint64_t and uint8_t MACROs ********************************************/

/* Note: Min of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINU64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINU64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint8_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U8_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of uint64_t and uint16_t MACROs ********************************************/

/* Note: Min of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINU64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINU64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint16_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of uint64_t and uint32_t MACROs ********************************************/

/* Note: Min of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINU64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINU64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          uint64_t op1;\
					  uint32_t op2; \
                                          uint64_t rslt_lo; \
                                          uint64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (uint64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (uint64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (uint64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_U64U32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of int64_t and int8_t MACROs ********************************************/

/* Note: Min of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64S8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = INT8_MIN; \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64S8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
					  _MUL_TEST_S64S8_(&op1, &op2, &rslt_lo, &rslt_hi);\


/*********************************** Multiplication Test min of int64_t and int16_t MACROs ********************************************/

/* Note: Min of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64S16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = INT16_MIN; \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64S16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S16_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of int64_t and int32_t MACROs ********************************************/

/* Note: Min of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64S32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = INT32_MIN; \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi); \
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64S32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1;\
					  int32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (int32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = (int64_t)data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = (int64_t)data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64S32_(&op1, &op2, &rslt_lo, &rslt_hi);


/*********************************** Multiplication Test min of int8_t and uint64_t MACROs ********************************************/

/* Note: Min of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS8U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT8_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS8U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int8_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int8_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S8U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test min of int16_t and uint64_t MACROs ********************************************/

/* Note: Min of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS16U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT16_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS16U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int16_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int16_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S16U64_(&op1, &op2, &rslt_lo, &rslt_hi);\					  


/*********************************** Multiplication Test min of int32_t and uint64_t MACROs ********************************************/

/* Note: Min of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS32U64(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT32_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS32U64_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int32_t op1; uint64_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int32_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint64_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S32U64_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test min of int64_t and uint8_t MACROs ********************************************/

/* Note: Min of 64-bit and 8-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64U8(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64U8_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint8_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint8_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U8_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test min of int64_t and uint16_t MACROs ********************************************/

/* Note: Min of 64-bit and 16-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64U16(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64U16_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint16_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          int64_t rslt_tb_lo; \
					  int64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint16_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                        _MUL_TEST_S64U16_(&op1, &op2, &rslt_lo, &rslt_hi);\
					  

/*********************************** Multiplication Test min of int64_t and uint32_t MACROs ********************************************/

/* Note: Min of 64-bit and 32-bit operand multiplication will create result of 128-bit */

/* Macro for MUL test without spike (assembly) */
#define MUL_TEST_MINS64U32(mb,op1,op2,rslt_lo,rslt_hi,tn) \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          op1 = INT64_MIN; \
                                          op2 = 0; \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\
                                          actual_result[(tn-1)*4 + 0] = op1; \
                                          actual_result[(tn-1)*4 + 1] = op2; \
                                          actual_result[(tn-1)*4 + 2] = rslt_lo; \
					  actual_result[(tn-1)*4 + 3] = rslt_hi;

/* Macro for MUL test with spike (assembly) */
#define MUL_TEST_MINS64U32_SPIKE(op1,op2,rslt_lo,rslt_hi,rslt_tb_lo,rslt_tb_hi,tn)  \
                                          int64_t op1; uint32_t op2; \
                                          int64_t rslt_lo; \
                                          int64_t rslt_hi; \
                                          uint64_t rslt_tb_lo; \
					  uint64_t rslt_tb_hi; \
                                          op1        = (int64_t)data[(tn-1)*4 + 0]; \
                                          op2        = (uint32_t)data[(tn-1)*4 + 1]; \
                                          rslt_tb_lo = data[(tn-1)*4 + 2]; \
					  rslt_tb_hi = data[(tn-1)*4 + 3]; \
                                          _MUL_TEST_S64U32_(&op1, &op2, &rslt_lo, &rslt_hi);\
					 



//////////////////////////// Addition ///////////////////////////////////

////////////////////// Part 1 & 2 //////////////////////////////////
#define ADD_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8_(&op1, &op2, &rslt_full);

// Macro for ADD test without spike (C) 
#define ADD_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
					  

// Macro for ADD test with spike (C) 
#define ADD_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint16_t)op1 + op2;



////////////////  S8 ////////////////////
#define ADD_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          _ADD_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
					  int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  _ADD_TEST_S8_(&op1, &op2, &rslt_full);

// Macro for ADD test without spike (C) 
#define ADD_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for ADD test with spike (C) 
#define ADD_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


/////////////////////// U16 /////////////////////////////
#define ADD_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _ADD_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
		
#define ADD_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U16_(&op1, &op2, &rslt_full);



// Macro for ADD test without spike (C) 
#define ADD_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
		
// Macro for ADD test with spike (C) 
#define ADD_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 + op2;

///////////////////// S16 /////////////////////////////
#define ADD_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          _ADD_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S16_(&op1, &op2, &rslt_full);


// Macro for ADD test without spike (C) 
#define ADD_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 + op2;


/////////////////// U32 //////////////////
#define ADD_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _ADD_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U32_(&op1, &op2, &rslt_full);


// Macro for ADD test without spike (C) 
#define ADD_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for ADD test with spike (C) 
#define ADD_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 + op2;


////////////////////// S32//////////////////////////
#define ADD_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S32_(&op1, &op2, &rslt_full);


// Macro for ADD test without spike (C) 
#define ADD_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 + op2;
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////// U64 //////////////////
/*#define ADD_TEST_U64(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _ADD_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U32_(&op1, &op2, &rslt_full);*/


// Macro for ADD test without spike (C) 
#define ADD_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for ADD test with spike (C) 
#define ADD_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 + op2;


////////////////////// S32//////////////////////////
/*#define ADD_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _ADD_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

#define ADD_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S32_(&op1, &op2, &rslt_full);
*/

// Macro for ADD test without spike (C) 
#define ADD_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 + op2;



////////////////////////////////////////////////// Addition part 3 /////////////////////////////////
 // Macro for ADD test without spike (C) ADD_TEST_U816EC_C 
#define ADD_TEST_U816EC_C(mb,op1,op2,rslt_full,tn,t) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  int i;\
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for ADD test with spike (C) 
#define ADD_TEST_U816EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
					  int i;\
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 + op2;\


//////////////////////////////U8S16 C code //////
 // Macro for ADD test without spike (C) ADD_TEST_U8S16EC_C 
#define ADD_TEST_U8S16EC_C(mb,op1,op2,rslt_full,tn,t) \
					  uint8_t op1; \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  int i;\
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (int16_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for ADD test with spike (C) 
#define ADD_TEST_U8S16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint8_t op1;  \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  int32_t rslt_tb; \
					  int i;\
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 + op2;\

///////////////////////////////////

//////////////////////////////U8S32 C code //////
 // Macro for ADD test without spike (C) ADD_TEST_U8S16EC_C 
#define ADD_TEST_U8S32EC_C(mb,op1,op2,rslt_full,tn,t) \
					  uint8_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int i;\
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for ADD test with spike (C) 
#define ADD_TEST_U8S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint8_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  int i;\
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 + op2;\

///////////////////////////////////

//////////////////////////////U16S32 C code //////
 // Macro for ADD test without spike (C) ADD_TEST_U8S16EC_C 
#define ADD_TEST_U16S32EC_C(mb,op1,op2,rslt_full,tn,t) \
					  uint16_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int i;\
					  op1 = (uint16_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for ADD test with spike (C) 
#define ADD_TEST_U16S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint16_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  int i;\
					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 + op2;\

///////////////////////////////////
// Macro for ADD test without spike (C) ADD_TEST_U832_C 
#define ADD_TEST_U832_C(mb,op1,op2,rslt_full,tn,t) \
					  uint8_t op1; \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  int i;\
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (uint64_t)(op1 + op2); \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
// Macro for ADD test with spike (C) 
#define ADD_TEST_U832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint8_t op1;  \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
					  int i;\
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 + op2;\

// Macro for ADD test without spike (C) ADD_TEST_U1632_C 
#define ADD_TEST_U1632_C(mb,op1,op2,rslt_full,tn,t) \
					  uint16_t op1; \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  int i;\
					  op1 = (uint16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					

					  
// Macro for ADD test with spike (C) 
#define ADD_TEST_U1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          uint16_t op1;  \
					  uint32_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
					  int i;\
					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1 ]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2 ]; \
                                          rslt_full = (uint64_t)op1 + op2;\



////////
// Macro for ADD test without spike (C) 
#define ADD_TEST_S816_C(mb,op1,op2,rslt_full,tn,t) \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          int i;\
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int16_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          int8_t op1;\
					  int16_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


////////////////////////////////////////////////////////////////////////////////////////////////////


// Macro for ADD test without spike (C) ADD_TEST_S832_C 

#define ADD_TEST_S832_C(mb,op1,op2,rslt_full,tn,t) \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          int i;\
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          int8_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


////////////////////////////////////////////////////////////////////////////////////////////////////


// Macro for ADD test without spike (C) ADD_TEST_S1632_C 

#define ADD_TEST_S1632_C(mb,op1,op2,rslt_full,tn,t) \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          int i;\
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (C) 
#define ADD_TEST_S1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
                                          int16_t op1;\
					  int32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


// Macro for ADD test without spike (C) ADD_TEST_S8U8_C 

#define ADD_TEST_S8U8_C(mb,op1,op2,rslt_full,tn,t) \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int i;\
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint8_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int8_t op1;\
					  uint8_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for ADD test without spike (C) ADD_TEST_S16U16_C 

#define ADD_TEST_S16U16_C(mb,op1,op2,rslt_full,tn,t) \
					  int16_t op1;\
					  uint16_t op2; \
	                                  int32_t rslt_full; \
                                          int i;\
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int16_t op1;\
					  uint16_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;



////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for ADD test without spike (C) ADD_TEST_S32U32_C 

#define ADD_TEST_S32U32_C(mb,op1,op2,rslt_full,tn,t) \
					  int32_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int i;\
					  op1 = (int32_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S32U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int32_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;


//////////

// Macro for ADD test without spike (C) ADD_TEST_S8U16_C 

#define ADD_TEST_S8U16_C(mb,op1,op2,rslt_full,tn,t) \
					  int8_t op1;\
					  uint16_t op2; \
	                                  int32_t rslt_full; \
                                          int i;\
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int8_t op1;\
					  uint16_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;



////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for ADD test without spike (C) ADD_TEST_S8U32_C 

#define ADD_TEST_S8U32_C(mb,op1,op2,rslt_full,tn,t) \
					  int8_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int i;\
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S8U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int8_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;



////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for ADD test without spike (C) ADD_TEST_S16U32_C 

#define ADD_TEST_S16U32_C(mb,op1,op2,rslt_full,tn,t) \
					  int16_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int i;\
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = op1 + op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for ADD test with spike (C) 
#define ADD_TEST_S16U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,k)  \
					  int16_t op1;\
					  uint32_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 + op2;







////////////////////////////////////////////////// Addition part 4 /////////////////////////////////

///////////////////////////U8U16//////////////////

#define ADD_TEST_U8U16(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint16_t op2 ; \
                                          uint32_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _ADD_TEST_U8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint16_t  op2; \
                                          uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8U16_(&op1, &op2, &rslt_full);

///////////////////U8U32//////////////////////////

#define ADD_TEST_U8U32(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint32_t op2 ; \
                                          uint64_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _ADD_TEST_U8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint32_t  op2; \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8U32_(&op1, &op2, &rslt_full);

///////////////////U8S8//////////////////////////

#define ADD_TEST_U8S8(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  int8_t op2 ; \
                                          int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
                                          _ADD_TEST_U8S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U8S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  int8_t  op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8S8_(&op1, &op2, &rslt_full);

///////////////////U8S16//////////////////////////

#define ADD_TEST_U8S16(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  int16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _ADD_TEST_U8S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  int16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8S16_(&op1, &op2, &rslt_full);

///////////////////U8S32//////////////////////////

#define ADD_TEST_U8S32(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_U8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8S32_(&op1, &op2, &rslt_full);


///////////////////////////U8U16//////////////////

#define ADD_TEST_U16U32(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  uint32_t op2 ; \
                                          uint64_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _ADD_TEST_U16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  uint32_t  op2; \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U16U32_(&op1, &op2, &rslt_full);


///////////////////U16S8//////////////////////////

#define ADD_TEST_U16S8(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  int8_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
                                          _ADD_TEST_U16S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U16S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  int8_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U16S8_(&op1, &op2, &rslt_full);


///////////////////U16S16//////////////////////////

#define ADD_TEST_U16S16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  int16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _ADD_TEST_U16S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U16S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  int16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U16S16_(&op1, &op2, &rslt_full);

///////////////////U16S32//////////////////////////

#define ADD_TEST_U16S32(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_U16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U16S32_(&op1, &op2, &rslt_full);


///////////////////U32S8//////////////////////////

#define ADD_TEST_U32S8(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1; \
					  int8_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
                                          _ADD_TEST_U32S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U32S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
					  int8_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U32S8_(&op1, &op2, &rslt_full);


///////////////////U32S16//////////////////////////

#define ADD_TEST_U32S16(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1; \
					  int16_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _ADD_TEST_U32S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U32S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
					  int16_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U32S16_(&op1, &op2, &rslt_full);

///////////////////U32S32//////////////////////////

#define ADD_TEST_U32S32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_U32S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_U32S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U32S32_(&op1, &op2, &rslt_full);

///////////////////S8S16//////////////////////////

#define ADD_TEST_S8S16(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _ADD_TEST_S8S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_S8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S8S16_(&op1, &op2, &rslt_full);


///////////////////S8S32//////////////////////////

#define ADD_TEST_S8S32(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_S8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_S8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S8S32_(&op1, &op2, &rslt_full);

///////////////////S16S32//////////////////////////

#define ADD_TEST_S16S32(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _ADD_TEST_S16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define ADD_TEST_S16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_S16S32_(&op1, &op2, &rslt_full);



////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////---- Immediate Part 5 -----///////////////////////////////////
/////////////////////////////-----Compliance Test -------///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////// Addition Test uint8_t TEST_RR_SRC1_EQ_DEST/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_SRC2_EQ_DEST/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_SRC12_EQ_DEST/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _ADD_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_ZEROSRC1/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8ZEROSRC1_(&op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_ZEROSRC2/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _ADD_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8ZEROSRC2_(&op1, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_ZEROSRC12/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _ADD_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8ZEROSRC12_(&rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_ZERODEST/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_DEST_BYPASS/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_SRC12_BYPASS/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);



//////////////////////////////////// Addition Test uint8_t TEST_RR_SRC21_BYPASS/////////////////////////////////////////////

// Note: 8-bit operand Addition will create result of 16-bit //

// Macro for ADD test without spike (assembly) //
#define ADD_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _ADD_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for ADD test with spike (assembly) //
#define ADD_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _ADD_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);



////////////////////////////////////////////////////////////////////////////////////////
////                                                                             ///////
////                         Addition Immediate ADDI                             ///////
////////////////////////////////////////////////////////////////////////////////////////

// Macros for I-Type instruction test 
#define TEST_ADDI_INSN_I(mb, insn, op1, imm, result, tn) \
		        int64_t op1, op2; \
	            int64_t result; \
                op1 = (uint64_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_ADDI_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn) \
		        int64_t op1, op2; \
	            int64_t result; \
	        	int64_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (add_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 


// Macros for I-Type instruction test 
#define TEST_ADDIW_INSN_I(mb, insn, op1, imm, result, tn) \
		        int32_t op1, op2; \
	            int32_t result; \
                op1 = (uint32_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_ADDIW_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn) \
		        int32_t op1, op2; \
	            int32_t result; \
	        	int32_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (add_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 





//////////////////////////// Subtraction  Part 1 and Part 2 ///////////////////////////////////

////////////////  U8 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
					  

// Macro for SUB test with spike (C) 
#define SUB_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
					  int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int16_t)op1 - op2;

// Macro for SUB test without spike - Assembly

#define SUB_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8_(&op1, &op2, &rslt_full);

////////////////  S8 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for SUB test with spike (C) 
#define SUB_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 - op2;


// Macro for SUB test without spike - Assembly

#define SUB_TEST_S8(mb,op1,op2,rslt_full,tn) \
					  int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
				          _SUB_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8_(&op1, &op2, &rslt_full);

////////////////  U16 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
		
// Macro for SUB test with spike (C) 
#define SUB_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          int32_t rslt_full; \
					  int32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 - op2;

// Macro for SUB test without spike - Assembly

#define SUB_TEST_U16(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
				          _SUB_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U16_(&op1, &op2, &rslt_full);

////////////////  S16 ////////////////////


// Macro for SUB test without spike (C) 
#define SUB_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (C) 
#define SUB_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 - op2;


// Macro for SUB test without spike - Assembly

#define SUB_TEST_S16(mb,op1,op2,rslt_full,tn) \
					  int16_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
				          _SUB_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S16_(&op1, &op2, &rslt_full);


////////////////  U32 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          int64_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for SUB test with spike (C) 
#define SUB_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          int64_t rslt_full;  \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;


// Macro for SUB test without spike - Assembly

#define SUB_TEST_U32(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SUB_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U32_(&op1, &op2, &rslt_full);


////////////////  S32 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (C) 
#define SUB_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;

// Macro for SUB test without spike - Assembly

#define SUB_TEST_S32(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SUB_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S32_(&op1, &op2, &rslt_full);

////////////////////////////////////////////////////
////////////////  U64 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          int64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for SUB test with spike (C) 
#define SUB_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          int64_t rslt_full;  \
                                          int64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;

/*
// Macro for SUB test without spike - Assembly

#define SUB_TEST_U64(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1, op2; \
	                                  int64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
				          _SUB_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U32_(&op1, &op2, &rslt_full);

*/
////////////////  S64 ////////////////////

// Macro for SUB test without spike (C) 
#define SUB_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (C) 
#define SUB_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;
/*
// Macro for SUB test without spike - Assembly

#define SUB_TEST_S32(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SUB_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike - Assembly
#define SUB_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S32_(&op1, &op2, &rslt_full);

*/

//////////////////////////// Subtraction  Part 3 ///////////////////////////////////

 // Macro for SUB test without spike (C) SUB_TEST_U8U16EC_C 
#define SUB_TEST_U8U16EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_U8U16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint16_t op2; \
	                                  int32_t rslt_full; \
					  int32_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 - op2;\

 // Macro for SUB test without spike (C) SUB_TEST_U8U32EC_C 
#define SUB_TEST_U8U32EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_U8U32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_U16U32EC_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1; \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (uint16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_U16U32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;  \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C) SUB_TEST_S8S16EC_C 
#define SUB_TEST_S8S16EC_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1; \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int16_t)(*p); \
					  p++;\
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S8S16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;  \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  int32_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 - op2;\

#define SUB_TEST_S8S32EC_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S8S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C) 
#define SUB_TEST_S16S32EC_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_S16S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_U8S16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  int32_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 - op2;\

#define SUB_TEST_U8S16EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  int16_t op2; \
	                                  int32_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (int16_t)(*p); \
					  p++;\
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S8U8EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;  \
					  uint8_t op2; \
	                                  int32_t rslt_full; \
					  int32_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_S8U8EC_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1; \
					  uint8_t op2; \
	                                  int32_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint8_t)(*p); \
					  p++;\
				          rslt_full = op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S16U16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;  \
					  uint16_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\


#define SUB_TEST_S16U16EC_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1; \
					  uint16_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S32U32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;  \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int32_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_S32U32EC_C(mb,op1,op2,rslt_full,tn) \
					  int32_t op1; \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int32_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\


// Macro for SUB test with spike (C) 
#define SUB_TEST_S8U16EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;  \
					  uint16_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_S8U16EC_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1; \
					  uint16_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint16_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_S8U32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;  \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_S8U32EC_C(mb,op1,op2,rslt_full,tn) \
					  int8_t op1; \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int8_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_S16U32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;  \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (int16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_S16U32EC_C(mb,op1,op2,rslt_full,tn) \
					  int16_t op1; \
					  uint32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (int16_t)(*p); \
					  p++;\
                                          op2 = (uint32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_U8S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (uint8_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_U8S32EC_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (uint8_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\

// Macro for SUB test with spike (C) 
#define SUB_TEST_U16S32EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;  \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  int64_t rslt_tb; \
					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 - op2;\

 // Macro for SUB test without spike (C)  
#define SUB_TEST_U16S32EC_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1; \
					  int32_t op2; \
	                                  int64_t rslt_full; \
					  op1 = (uint16_t)(*p); \
					  p++;\
                                          op2 = (int32_t)(*p); \
					  p++;\
				          rslt_full = (int64_t)op1 - op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\



////////////////////////////////////////////////// Subtraction part 4 /////////////////////////////////

///////////////////////////U8U16//////////////////

#define SUB_TEST_U8U16(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _SUB_TEST_U8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8U16_(&op1, &op2, &rslt_full);

///////////////////U8U32//////////////////////////

#define SUB_TEST_U8U32(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  uint32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SUB_TEST_U8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  uint32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8U32_(&op1, &op2, &rslt_full);


///////////////////U16U32//////////////////////////

#define SUB_TEST_U16U32(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  uint32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SUB_TEST_U16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  uint32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U16U32_(&op1, &op2, &rslt_full);


///////////////////S8S16//////////////////////////

#define SUB_TEST_S8S16(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _SUB_TEST_S8S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8S16_(&op1, &op2, &rslt_full);

///////////////////S8S32//////////////////////////

#define SUB_TEST_S8S32(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SUB_TEST_S8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8S32_(&op1, &op2, &rslt_full);

///////////////////S16S32//////////////////////////

#define SUB_TEST_S16S32(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SUB_TEST_S16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S16S32_(&op1, &op2, &rslt_full);





///////////////////U8S16//////////////////////////

#define SUB_TEST_U8S16(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  int16_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          _SUB_TEST_U8S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  int16_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8S16_(&op1, &op2, &rslt_full);

///////////////////S8U8//////////////////////////

#define SUB_TEST_S8U8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint8_t op2 ; \
                                          int32_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
                                          _SUB_TEST_S8U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S8U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint8_t  op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8U8_(&op1, &op2, &rslt_full);


///////////////////S16U16//////////////////////////

#define SUB_TEST_S16U16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  uint16_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _SUB_TEST_S16U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S16U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  uint16_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S16U16_(&op1, &op2, &rslt_full);

///////////////////S32U32//////////////////////////

#define SUB_TEST_S32U32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1; \
					  uint32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SUB_TEST_S32U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S32U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
					  uint32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S32U32_(&op1, &op2, &rslt_full);



///////////////////S8U16//////////////////////////

#define SUB_TEST_S8U16(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint16_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _SUB_TEST_S8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint16_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8U16_(&op1, &op2, &rslt_full);

///////////////////S8U32//////////////////////////

#define SUB_TEST_S8U32(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1; \
					  uint32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SUB_TEST_S8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
					  uint32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S8U32_(&op1, &op2, &rslt_full);

///////////////////S16U32//////////////////////////

#define SUB_TEST_S16U32(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1; \
					  uint32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SUB_TEST_S16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_S16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
					  uint32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_S16U32_(&op1, &op2, &rslt_full);


///////////////////U8S32//////////////////////////

#define SUB_TEST_U8S32(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SUB_TEST_U8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8S32_(&op1, &op2, &rslt_full);

///////////////////U16S32//////////////////////////

#define SUB_TEST_U16S32(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1; \
					  int32_t op2 ; \
                                          int64_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SUB_TEST_U16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


#define SUB_TEST_U16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
					  int32_t  op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U16S32_(&op1, &op2, &rslt_full);






//////////////////////////////////////  Part5  /////////////////////////

//////////////////////////////////////// Subtraction Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 8-bit operand Subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_SRC2_EQ_DEST*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _SUB_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);



//********************************** subtraction Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8ZEROSRC1_(&op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SUB_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8ZEROSRC2_(&op1, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SUB_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8ZEROSRC12_(&rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);



//********************************** Subtraction Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Subtraction will create result of 16-bit 

// Macro for SUB test without spike (assembly) 
#define SUB_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SUB_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SUB test with spike (assembly) 
#define SUB_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SUB_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                                 //
//                                                Division Test Cases Macros                                                       //  
//                                                                                                                                 //         
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////// Division Test uint8_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _DIV_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8_(&op1, &op2, &rslt_full);

// Macro for DIV test without spike (C) 
#define DIV_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
										  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 / op2;



//////////////////////////////////// Division Test int8_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
										  int8_t rslt_tb; \
										  op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  _DIV_TEST_S8_(&op1, &op2, &rslt_full);

// Macro for DIV test without spike (C) 
#define DIV_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test uint16_t MACROs ///////////////////////////////////////////


// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _DIV_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U16_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for DIV test with spike (C) 
#define DIV_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
										  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 / op2;


//////////////////////////////////// Division Test int16_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _DIV_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S16_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 / op2;


//////////////////////////////////// Division Test uint32_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _DIV_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U32_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 / op2;


//////////////////////////////////// Division Test int32_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _DIV_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S32_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 / op2;



//////////////////////////////////// Division Test uint64_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U64(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _DIV_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U64_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 / op2;


//////////////////////////////////// Division Test int64_t MACROs ///////////////////////////////////////////

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S64(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _DIV_TEST_S64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S64_(&op1, &op2, &rslt_full);


// Macro for DIV test without spike (C) 
#define DIV_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 / op2;



///////////////////////////////////////////// Division Part 3 /////////////////////////////////////////////////
//

///////////////////////////////////////// Division Test uint16_t and uint8_t MACROs //////////////////////////////////////////

// Macro for DIV test without spike (C)  
#define DIV_TEST_U816EC_C(mb,op1,op2,rslt_full,tn) \
									  uint16_t op1; \
									  uint8_t op2; \
	                                  uint16_t rslt_full; \
									  op1 = (uint16_t)(*p); \
									  p++;\
                                      op2 = (uint8_t)(*p); \
									  p++;\
									  rslt_full = op1 / op2; \
                                      actual_result[(tn-1)*3 + 0 ] = op1; \
                                      actual_result[(tn-1)*3 + 1 ] = op2; \
                                      actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
// Macro for DIV test with spike (C) 
#define DIV_TEST_U816EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;  \
										  uint8_t op2; \
										  uint16_t rslt_full; \
										  uint16_t rslt_tb; \
										  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint16_t)op1 / op2;\
				  

//////////////////////////////////// Division Test uint8_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  

#define DIV_TEST_U832_C(mb,op1,op2,rslt_full,tn) \
									  uint32_t op1; \
									  uint8_t op2; \
	                                  uint32_t rslt_full; \
									  op1 = (uint32_t)(*p); \
									  p++;\
									  op2 = (uint8_t)(*p); \
									  p++;\
									  rslt_full = (uint32_t)op1 / op2;\
                               		  actual_result[(tn-1)*3 + 0 ] = op1; \
                                      actual_result[(tn-1)*3 + 1 ] = op2; \
                                      actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					 
// Macro for DIV test with spike (C) 
#define DIV_TEST_U832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;  \
										  uint8_t op2; \
										  uint32_t rslt_full; \
										  uint32_t rslt_tb; \
										  op1 = (uint32_t)data[(tn-1)*3 + 0  ]; \
										  op2 = (uint8_t)data[(tn-1)*3 + 1]; \
										  rslt_full = (uint32_t)op1 / op2;\
										  rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \       	          

//////////////////////////////////// Division Test uint16_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_U1632_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint16_t op2; \
										  uint32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (uint16_t)(*p); \
										  p++;\
										  rslt_full = (uint32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
// Macro for DIV test with spike (C) 
#define DIV_TEST_U1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;  \
										  uint16_t op2; \
										  uint32_t rslt_full; \
										  uint32_t rslt_tb; \
										  op1 = (uint32_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1 ]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2 ]; \
                                          rslt_full = (uint32_t)op1 / op2;\
					  

//////////////////////////////////// Division Test int8_t and int16_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S816_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
										  op1 = (int16_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test int8_t and int32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S832_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int16_t and int32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S1632_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (C) 
#define DIV_TEST_S1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int8_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S8U8_C(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1;\
										  int8_t op2; \
										  int8_t rslt_full; \
										  op1 = (uint8_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for DIV test with spike (C) 
#define DIV_TEST_S8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint8_t op1;\
										  int8_t op2; \
										  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test int16_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S16U16_C(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1;\
										  int16_t op2; \
										  int16_t rslt_full; \
										  op1 = (uint16_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for DIV test with spike (C) 
#define DIV_TEST_S16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint16_t op1;\
										  int16_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test int32_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S32U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int32_t op2; \
										  int32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int32_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for DIV test with spike (C) 
#define DIV_TEST_S32U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int32_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int8_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S8U16_C(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
										  op1 = (uint16_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for DIV test with spike (C) 
#define DIV_TEST_S8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test int8_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S8U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            
// Macro for DIV test with spike (C) 
#define DIV_TEST_S8U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int16_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S16U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for DIV test with spike (C) 
#define DIV_TEST_S16U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int16_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S16U8_C(mb,op1,op2,rslt_full,tn) \
										  int16_t op1;\
										  uint8_t op2; \
										  int16_t rslt_full; \
										  op1 = (int16_t)(*p); \
										  p++;\
                                          op2 = (uint8_t)(*p); \
										  p++;\
										  rslt_full = op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            
// Macro for DIV test with spike (C) 
#define DIV_TEST_S16U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int16_t op1;\
										  uint8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 / op2;


//////////////////////////////////// Division Test int32_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S32U8_C(mb,op1,op2,rslt_full,tn) \
										  int32_t op1;\
										  uint8_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (uint8_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

 
// Macro for DIV test with spike (C) 
#define DIV_TEST_S32U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int32_t op1;\
										  uint8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;


//////////////////////////////////// Division Test int32_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for DIV test without spike (C)  
#define DIV_TEST_S32U16_C(mb,op1,op2,rslt_full,tn) \
										  int32_t op1;\
										  uint16_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (uint16_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 / op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for DIV test with spike (C) 
#define DIV_TEST_S32U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int32_t op1;\
										  uint16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 / op2;



////////////////////////////////////////////////////////////////////////////////////////////////////

                            /* Division Test Part 4 ( Assembly)*/
///////////////////////////////////////////////////////////////////////////////////////////////////


/* MACROS for DIV Test U8U16 */

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  uint8_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _DIV_TEST_U816_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  uint8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U816_(&op1, &op2, &rslt_full);

/* Macros for Division test cases U8U32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint8_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _DIV_TEST_U832_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  uint8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U832_(&op1, &op2, &rslt_full);


/* Macros for Division test cases U16U32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U16U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint16_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
										  _DIV_TEST_U1632_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  uint16_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U1632_(&op1, &op2, &rslt_full);


/* Macros for Division test cases S8S16 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8S16(mb,op1,op2,rslt_full,tn) \
										  int16_t op1; \
										  int8_t op2; \
	                                      int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S816_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S816_(&op1, &op2, &rslt_full);


/* Macros for Division test cases S8S32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  int8_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S832_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S832_(&op1, &op2, &rslt_full);

/* Macros for Division test cases S16S32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S16S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  int16_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _DIV_TEST_S1632_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S1632_(&op1, &op2, &rslt_full);


/* Macros for Division test cases S8U8 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8U8(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1; \
										  int8_t op2; \
	                                      int16_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S8U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S8U8_(&op1, &op2, &rslt_full);


/* Macros for Division test cases S16U16 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S16U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  int16_t op2; \
	                                      int16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _DIV_TEST_S16U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S16U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  int16_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S16U16_(&op1, &op2, &rslt_full);

/* Macros for Division test cases S32U32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S32U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int32_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
										  _DIV_TEST_S32U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S32U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int32_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S32U32_(&op1, &op2, &rslt_full);

/* Macros for Division test cases S8U16 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  int8_t op2; \
	                                      int16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S8U16_(&op1, &op2, &rslt_full);


/* Macros for Division test cases S8U32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S8U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int8_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _DIV_TEST_S8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S8U32_(&op1, &op2, &rslt_full);

/* Macros for Division test cases S16U32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_S16U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int16_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _DIV_TEST_S16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_S16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_S16U32_(&op1, &op2, &rslt_full);

/* Macros for Division test cases U8S32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  uint8_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _DIV_TEST_U8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  uint8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8S32_(&op1, &op2, &rslt_full);


/* Macros for Division test cases U16S32 */

	// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U16S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  uint16_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
										  _DIV_TEST_U16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  uint16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U16S32_(&op1, &op2, &rslt_full);




//////////////////////////////////////  Part5  /////////////////////////

//////////////////////////////////////// Division Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////



// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         				  _DIV_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  	  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Division Test uint8_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                 	  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          				  _DIV_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _DIV_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);

//********************************** Division Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _DIV_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8ZEROSRC1_(&op2, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _DIV_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8ZEROSRC2_(&op1, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _DIV_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8ZEROSRC12_(&rslt_full);


//********************************** Division Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _DIV_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _DIV_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _DIV_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Division Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Division will create result of 16-bit 

// Macro for DIV test without spike (assembly) 
#define DIV_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _DIV_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for DIV test with spike (assembly) 
#define DIV_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _DIV_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);

//////////////////////////////////////////////// Division Part 6 ////////////////////////////////////////////
/* Macro for  method  DIV test without spike (C)  */
#define DIV_TEST_MAX_C(mb,op1,op2,rslt_full,tn ,op1_dt , op2_dt , res_dt ,op1_val , op2_val ) \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  op1 = op1_val; \
                      op2 = op2_val; \
				      rslt_full = op1 / op2; \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro for method  DIV test with spike (C) */
#define DIV_TEST_MAX_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt , op2_dt , res_dt )  \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (op2_dt)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                      rslt_full = op1 / op2;


/* Macro for  method  DIV MIN test without spike (C)  */
#define DIV_TEST_MIN_C(mb,op1,op2,rslt_full,tn ,op1_dt , op2_dt , res_dt ,op1_val , op2_val ) \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  op1 = (op1_dt) op1_val; \
                      op2 = (op2_dt) op2_val; \
				      rslt_full = (res_dt) op1 / op2; \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro for method  DIV MIN test with spike (C) */
#define DIV_TEST_MIN_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt , op2_dt , res_dt )  \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (op2_dt)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                      rslt_full = (res_dt) op1 / op2;



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//




/////////////////////////////////////////////////////////AND////////////////////////////////////////////////////////

//////////////////////////////////////  Part1  ///////////////////////////////////

/*********************************** AND Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					                      uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          #ifdef FPGA_RUN \
                                          op1 = genrand_int32(); \
                                          op2 = genrand_int32(); \
				                          rslt_full = op1 & op2; \
                                          #else \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
                                          #endif      


/* Macro for AND test with spike (C) */
#define AND_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          #ifdef FPGA_RUN \
                                          op1 = genrand_int32(); \
                                          op2 = genrand_int32(); \
				                          rslt_full = op1 & op2; \
                                          #else \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full; 
				                          #endif 

/* Macro for AND test with spike (C) */
#define AND_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \

                                          #ifdef FPGA_RUN \
                                          op1 = genrand_int32(); \
                                          op2 = genrand_int32(); \
				                          rslt_full = op1 & op2; \

                                          #else \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
                                          #endif

/* Macro for AND test with spike (C) */
#define AND_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 & op2;


//////////////////////////////////////  Part2  ///////////////////////////////////////

/*********************************** AND Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for AND test without spike (assembly) */
#define AND_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         _AND_TEST_U8_(&op1, &op2, &rslt_full); \                                          
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (assembly) */
#define AND_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U8_(&op1, &op2, &rslt_full);


/*********************************** AND Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for AND test without spike (assembly) */
#define AND_TEST_U16(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
				          _AND_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (assembly) */
#define AND_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U16_(&op1, &op2, &rslt_full);


/*********************************** AND Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for AND test without spike (assembly) */
#define AND_TEST_U32(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (assembly) */
#define AND_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32_(&op1, &op2, &rslt_full);


/*********************************** AND Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for AND test without spike (assembly) */
#define AND_TEST_U64(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
				          _AND_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (assembly) */
#define AND_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U64_(&op1, &op2, &rslt_full);



//////////////////////////////////////  Part3  //////////////////////////////////

//////////////////////////////////////// And Test uint32_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_SRC12_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _AND_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full);


/********************************** And Test uint32_t TEST_RR_ZEROSRC1*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32ZEROSRC1_(&op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_ZEROSRC2*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _AND_TEST_U32ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32ZEROSRC2_(&op1, &rslt_full);


/********************************** And Test uint32_t TEST_RR_ZEROSRC12*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _AND_TEST_U32ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32ZEROSRC12_(&rslt_full);


/********************************** And Test uint32_t TEST_RR_ZERODEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32ZERODEST_(&op1, &op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_DEST_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_SRC12_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full);


/********************************** And Test uint32_t TEST_RR_SRC21_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for AND test without spike (assembly) 
#define AND_TEST_U32SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _AND_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for AND test with spike (assembly) 
#define AND_TEST_U32SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _AND_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full);


//////////////////////////////////////  Part4  ////////////////////////////////////

/*********************************** AND Test Max of uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Max of uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for AND test with spike (C) */
#define AND_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Max of uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Max of uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 & op2;


/*********************************** AND Test Min of uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Min of uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for AND test with spike (C) */
#define AND_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Min of uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** AND Test Min of uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for AND test without spike (C) */
#define AND_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for AND test with spike (C) */
#define AND_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 & op2;


////////////////////////////////////////////////////////////////////////////////////////
////                                                                             ///////
////                              AND Immediate ANDI                             ///////
////////////////////////////////////////////////////////////////////////////////////////

// Macros for I-Type instruction test 8 bit
#define TEST_ANDI_INSN_I8(mb, insn, op1, imm, result, tn) \
		        uint8_t op1;\
                int32_t op2; \
	            uint8_t result; \
                op1 = (uint8_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 16 bit
#define TEST_ANDI_INSN_I16(mb, insn, op1, imm, result, tn) \
		        uint16_t op1;\
                int32_t op2;\
	            uint16_t result; \
                op1 = (uint16_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 32 bit
#define TEST_ANDI_INSN_I32(mb, insn, op1, imm, result, tn) \
		        uint32_t op1; \
	            int32_t op2;\
                uint32_t result; \
                op1 = (uint32_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 64 bit
#define TEST_ANDI_INSN_I64(mb, insn, op1, imm, result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
                op1 = (uint64_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 8 bit
#define TEST_ANDI_INSN_I_SPIKE8(insn, op1, imm, result, exp_result, tn) \
		        uint8_t op1; \
                int32_t op2; \
	            uint8_t result; \
	        	uint8_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (and_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 16 bit
#define TEST_ANDI_INSN_I_SPIKE16(insn, op1, imm, result, exp_result, tn) \
		        uint16_t op1; \
                int32_t op2;\
	            uint16_t result; \
	        	uint16_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (and_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 32 bit
#define TEST_ANDI_INSN_I_SPIKE32(insn, op1, imm, result, exp_result, tn) \
		        uint32_t op1; \
                int32_t op2;\
	            uint32_t result; \
	        	uint32_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (and_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 64 bit
#define TEST_ANDI_INSN_I_SPIKE64(insn, op1, imm, result, exp_result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
	        	uint64_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (and_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 






/*********************************** ANDI Test Max of uint8_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;


/*********************************** ANDI Test Max of uint16_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

/*********************************** ANDI Test Max of uint32_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = UINT32_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

/*********************************** ANDI Test Max of uint64_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

////////////////////////////////////////////////////////////
/*********************************** ANDI Test Min of uint8_t of  MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint8_t op2; \
	                                  uint8_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

/*********************************** ANDI Test Min of uint16_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

/*********************************** ANDI Test Min of uint32_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;

/*********************************** ANDI Test Min of uint64_t MACROs ********************************************/


/* Macro for ANDI test without spike (C) */
#define ANDI_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 & op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ANDI test with spike (C) */
#define ANDI_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 & op2;







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////OR

//////////////////////////////////////  Part1  ///////////////////////////////////

/*********************************** OR Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand or will create result of 8-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand or will create result of 16-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for OR test with spike (C) */
#define OR_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand or will create result of 32-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand or will create result of 64-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 | op2;


//////////////////////////////////////  Part2  ///////////////////////////////////////

/*********************************** OR Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand or will create result of 8-bit */

/* Macro for OR test without spike (assembly) */
#define OR_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _OR_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (assembly) */
#define OR_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U8_(&op1, &op2, &rslt_full);


/*********************************** OR Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand or will create result of 16-bit */

/* Macro for OR test without spike (assembly) */
#define OR_TEST_U16(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
				          _OR_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (assembly) */
#define OR_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U16_(&op1, &op2, &rslt_full);


/*********************************** OR Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand or will create result of 32-bit */

/* Macro for OR test without spike (assembly) */
#define OR_TEST_U32(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (assembly) */
#define OR_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32_(&op1, &op2, &rslt_full);


/*********************************** OR Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand or will create result of 64-bit */

/* Macro for OR test without spike (assembly) */
#define OR_TEST_U64(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
				          _OR_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (assembly) */
#define OR_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U64_(&op1, &op2, &rslt_full);



//////////////////////////////////////  Part3  //////////////////////////////////

//////////////////////////////////////// Or Test uint32_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_SRC12_EQ_DEST*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _OR_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_ZEROSRC1*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32ZEROSRC1_(&op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_ZEROSRC2*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _OR_TEST_U32ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32ZEROSRC2_(&op1, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_ZEROSRC12*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _OR_TEST_U32ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32ZEROSRC12_(&rslt_full);


/********************************** Or Test uint32_t TEST_RR_ZERODEST*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32ZERODEST_(&op1, &op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_DEST_BYPASS*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_SRC12_BYPASS*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full);


/********************************** Or Test uint32_t TEST_RR_SRC21_BYPASS*******************************************/

// Note: 32-bit operand or will create result of 32-bit 

// Macro for OR test without spike (assembly) 
#define OR_TEST_U32SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _OR_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for OR test with spike (assembly) 
#define OR_TEST_U32SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _OR_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full);


//////////////////////////////////////  Part4  ////////////////////////////////////

/*********************************** OR Test Max of uint8_t MACROs ********************************************/

/* Note: 8-bit operand or will create result of 8-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Max of uint16_t MACROs ********************************************/

/* Note: 16-bit operand or will create result of 16-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for OR test with spike (C) */
#define OR_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Max of uint32_t MACROs ********************************************/

/* Note: 32-bit operand or will create result of 32-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Max of uint64_t MACROs ********************************************/

/* Note: 64-bit operand or will create result of 64-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 | op2;


/*********************************** OR Test Min of uint8_t MACROs ********************************************/

/* Note: 8-bit operand or will create result of 8-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Min of uint16_t MACROs ********************************************/

/* Note: 16-bit operand or will create result of 16-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for OR test with spike (C) */
#define OR_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Min of uint32_t MACROs ********************************************/

/* Note: 32-bit operand or will create result of 32-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** OR Test Min of uint64_t MACROs ********************************************/

/* Note: 64-bit operand or will create result of 64-bit */

/* Macro for OR test without spike (C) */
#define OR_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for OR test with spike (C) */
#define OR_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 | op2;


////////////////////////////////////////////////////////////////////////////////////////
////                                                                             ///////
////                              OR Immediate ORI                             ///////
////////////////////////////////////////////////////////////////////////////////////////

// Macros for I-Type instruction test 8 bit
#define TEST_ORI_INSN_I8(mb, insn, op1, imm, result, tn) \
		        uint8_t op1;\
                int32_t op2; \
	            uint8_t result; \
                op1 = (uint8_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 16 bit
#define TEST_ORI_INSN_I16(mb, insn, op1, imm, result, tn) \
		        uint16_t op1;\
                int32_t op2;\
	            uint16_t result; \
                op1 = (uint16_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 32 bit
#define TEST_ORI_INSN_I32(mb, insn, op1, imm, result, tn) \
		        uint32_t op1; \
	            int32_t op2;\
                uint32_t result; \
                op1 = (uint32_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 64 bit
#define TEST_ORI_INSN_I64(mb, insn, op1, imm, result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
                op1 = (uint64_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 8 bit
#define TEST_ORI_INSN_I_SPIKE8(insn, op1, imm, result, exp_result, tn) \
		        uint8_t op1; \
                int32_t op2; \
	            uint8_t result; \
	        	uint8_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (or_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 16 bit
#define TEST_ORI_INSN_I_SPIKE16(insn, op1, imm, result, exp_result, tn) \
		        uint16_t op1; \
                int32_t op2;\
	            uint16_t result; \
	        	uint16_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (or_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 32 bit
#define TEST_ORI_INSN_I_SPIKE32(insn, op1, imm, result, exp_result, tn) \
		        uint32_t op1; \
                int32_t op2;\
	            uint32_t result; \
	        	uint32_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (or_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 64 bit
#define TEST_ORI_INSN_I_SPIKE64(insn, op1, imm, result, exp_result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
	        	uint64_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (or_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 





/*********************************** ORI Test Max of uint8_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;


/*********************************** ORI Test Max of uint16_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

/*********************************** ORI Test Max of uint32_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = UINT32_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

/*********************************** ORI Test Max of uint64_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

////////////////////////////////////////////////////////////
/*********************************** ORI Test Min of uint8_t of  MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint8_t op2; \
	                                  uint8_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

/*********************************** ORI Test Min of uint16_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

/*********************************** ORI Test Min of uint32_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;

/*********************************** ORI Test Min of uint64_t MACROs ********************************************/


/* Macro for ORI test without spike (C) */
#define ORI_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 | op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for ORI test with spike (C) */
#define ORI_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 | op2;





/////////////////////////////////////////////////////////XOR////////////////////////////////////////////////////////

//////////////////////////////////////  Part1  ///////////////////////////////////

/*********************************** XOR Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for XOR test with spike (C) */
#define XOR_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 ^ op2;


//////////////////////////////////////  Part2  ///////////////////////////////////////

/*********************************** XOR Test uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for XOR test without spike (assembly) */
#define XOR_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _XOR_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (assembly) */
#define XOR_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U8_(&op1, &op2, &rslt_full);


/*********************************** XOR Test uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for XOR test without spike (assembly) */
#define XOR_TEST_U16(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
				          _XOR_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (assembly) */
#define XOR_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U16_(&op1, &op2, &rslt_full);


/*********************************** XOR Test uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for XOR test without spike (assembly) */
#define XOR_TEST_U32(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (assembly) */
#define XOR_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32_(&op1, &op2, &rslt_full);


/*********************************** XOR Test uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for XOR test without spike (assembly) */
#define XOR_TEST_U64(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
				          _XOR_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (assembly) */
#define XOR_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U64_(&op1, &op2, &rslt_full);



//////////////////////////////////////  Part3  //////////////////////////////////

//////////////////////////////////////// XOR Test uint32_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_SRC12_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _XOR_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_ZEROSRC1*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32ZEROSRC1_(&op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_ZEROSRC2*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _XOR_TEST_U32ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32ZEROSRC2_(&op1, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_ZEROSRC12*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _XOR_TEST_U32ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32ZEROSRC12_(&rslt_full);


/********************************** XOR Test uint32_t TEST_RR_ZERODEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32ZERODEST_(&op1, &op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_DEST_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_SRC12_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full);


/********************************** XOR Test uint32_t TEST_RR_SRC21_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for XOR test without spike (assembly) 
#define XOR_TEST_U32SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _XOR_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for XOR test with spike (assembly) 
#define XOR_TEST_U32SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _XOR_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full);


//////////////////////////////////////  Part4  ////////////////////////////////////

/*********************************** XOR Test Max of uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Max of uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Max of uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Max of uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 ^ op2;


/*********************************** XOR Test Min of uint8_t MACROs ********************************************/

/* Note: 8-bit operand and will create result of 8-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Min of uint16_t MACROs ********************************************/

/* Note: 16-bit operand and will create result of 16-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Min of uint32_t MACROs ********************************************/

/* Note: 32-bit operand and will create result of 32-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XOR Test Min of uint64_t MACROs ********************************************/

/* Note: 64-bit operand and will create result of 64-bit */

/* Macro for XOR test without spike (C) */
#define XOR_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2; \
                                          uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
                                          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XOR test with spike (C) */
#define XOR_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 ^ op2;



////////////////////////////////////////////////////////////////////////////////////////
////                                                                             ///////
////                              XOR Immediate XORI                             ///////
////////////////////////////////////////////////////////////////////////////////////////

// Macros for I-Type instruction test 8 bit
#define TEST_XORI_INSN_I8(mb, insn, op1, imm, result, tn) \
		        uint8_t op1;\
                int32_t op2; \
	            uint8_t result; \
                op1 = (uint8_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 16 bit
#define TEST_XORI_INSN_I16(mb, insn, op1, imm, result, tn) \
		        uint16_t op1;\
                int32_t op2;\
	            uint16_t result; \
                op1 = (uint16_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 32 bit
#define TEST_XORI_INSN_I32(mb, insn, op1, imm, result, tn) \
		        uint32_t op1; \
	            int32_t op2;\
                uint32_t result; \
                op1 = (uint32_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test 64 bit
#define TEST_XORI_INSN_I64(mb, insn, op1, imm, result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
                op1 = (uint64_t)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 8 bit
#define TEST_XORI_INSN_I_SPIKE8(insn, op1, imm, result, exp_result, tn) \
		        uint8_t op1; \
                int32_t op2; \
	            uint8_t result; \
	        	uint8_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (xor_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 16 bit
#define TEST_XORI_INSN_I_SPIKE16(insn, op1, imm, result, exp_result, tn) \
		        uint16_t op1; \
                int32_t op2;\
	            uint16_t result; \
	        	uint16_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (xor_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 32 bit
#define TEST_XORI_INSN_I_SPIKE32(insn, op1, imm, result, exp_result, tn) \
		        uint32_t op1; \
                int32_t op2;\
	            uint32_t result; \
	        	uint32_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (xor_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



// Macros for I-Type instruction test (SPIKE) 64 bit
#define TEST_XORI_INSN_I_SPIKE64(insn, op1, imm, result, exp_result, tn) \
		        uint64_t op1; \
                int32_t op2; \
	            uint64_t result; \
	        	uint64_t exp_result; \
                op1        = data[(tn-1)*3 + 0]; \
                op2        = data[(tn-1)*3 + 1]; \
		        result     = data[(tn-1)*3 + 2]; \
	            asm volatile (xor_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 







/*********************************** XORI Test Max of uint8_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MAXU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT8_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MAXU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;


/*********************************** XORI Test Max of uint16_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MAXU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = UINT16_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MAXU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

/*********************************** XORI Test Max of uint32_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MAXU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = UINT32_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MAXU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

/*********************************** XORI Test Max of uint64_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MAXU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = UINT64_MAX; \
                                          op2 = 2045; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MAXU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

////////////////////////////////////////////////////////////
/*********************************** XORI Test Min of uint8_t of  MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MINU8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1;\
                      uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MINU8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
                                          uint8_t op2; \
	                                  uint8_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

/*********************************** XORI Test Min of uint16_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MINU16_C(mb,op1,op2,rslt_full,tn) \
					  uint16_t op1;\
                      uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MINU16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
                                          uint16_t op2; \
	                                  uint16_t rslt_full; \
					  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

/*********************************** XORI Test Min of uint32_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MINU32_C(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1;\
                      uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MINU32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
                                          uint32_t op2; \
	                                  uint32_t rslt_full; \
					  uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;

/*********************************** XORI Test Min of uint64_t MACROs ********************************************/


/* Macro for XORI test without spike (C) */
#define XORI_TEST_MINU64_C(mb,op1,op2,rslt_full,tn) \
					  uint64_t op1;\
                      uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          rslt_full = op1 ^ op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for XORI test with spike (C) */
#define XORI_TEST_MINU64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
                                          uint64_t op2; \
	                                  uint64_t rslt_full; \
					  uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 ^ op2;




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                                 //
//                                                Reminder Test Cases Macros                                                       //  
//                                                                                                                                 //         
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////// Reminder Test uint8_t MACROs ///////////////////////////////////////////




// Macro for DIV test with spike (C) 
#define REM_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
										  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 % op2;
//Macro for Rem test without spike(c)

#define REM_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
// Macro for REM test without spike (assembly) 
#define REM_TEST_U8(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _REM_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8_(&op1, &op2, &rslt_full);




//////////////////////////////////// Reminder Test int8 MACROS//////////////////////////////

//Macro for int8 reminder without spike(c)

#define REM_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

//MACRO for int8 reminder with spike(c) 

#define REM_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;
// Macro for REM test without spike (assembly) 
#define REM_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
										  int8_t rslt_tb; \
										  op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  _REM_TEST_S8_(&op1, &op2, &rslt_full);
//////////////////////////////////// Reminder  Test uint16_t MACROs ///////////////////////////////////////////
// Macro for REM test without spike (C) 
#define REM_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for REM test with spike (C) 
#define REM_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
										  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 % op2;

      // Macro for REM test without spike (assembly) 
#define REM_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _REM_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for REM test with spike (assembly) 
#define REM_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U16_(&op1, &op2, &rslt_full);
//////////////////////////////////// Reminder  Test int16_t MACROs ///////////////////////////////////////////

// Macro for REM test without spike (C) 
#define REM_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for REM test with spike (C) 
#define REM_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
										  int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 % op2;

 // Macro for REM test without spike (assembly) 
#define REM_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _REM_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S16_(&op1, &op2, &rslt_full);

//////////////////////////////////// Reminder Test uint32_t MACROs ///////////////////////////////////////////




// Macro for REM test without spike (C) 
#define REM_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 % op2;
 // Macro for REM test without spike (assembly) 
#define REM_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _REM_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U32_(&op1, &op2, &rslt_full);

//////////////////////////////////// Reminder Test int32_t MACROs ///////////////////////////////////////////


// Macro for REM test without spike (C) 
#define REM_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int32_t)op1 % op2;

// Macro for REM test without spike (assembly) 
#define REM_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _REM_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S32_(&op1, &op2, &rslt_full);


//////////////////////////////////// Reminder Test uint64_t MACROs ///////////////////////////////////////////


// Macro for REM test without spike (C) 
#define REM_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 % op2;

 // Macro for REM test without spike (assembly) 
#define REM_TEST_U64(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _REM_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U64_(&op1, &op2, &rslt_full);

//////////////////////////////////// Reminder Test int64_t MACROs ///////////////////////////////////////////


// Macro for REM test without spike (C) 
#define REM_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (int64_t)op1 % op2;

// Macro for REM test without spike (assembly) 
#define REM_TEST_S64(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _REM_TEST_S64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S64_(&op1, &op2, &rslt_full);


///////////////////////////////////////////// Reminder Part 3 ///////////////////////////////////////////////////////////////
//

///////////////////////////////////////// Reminder Test uint16_t and uint8_t MACROs //////////////////////////////////////////

// Macro for Reminder test without spike (C)  
#define REM_TEST_U816EC_C(mb,op1,op2,rslt_full,tn) \
									  uint16_t op1; \
									  uint8_t op2; \
	                                  uint16_t rslt_full; \
									  op1 = (uint16_t)(*p); \
									  p++;\
                                      op2 = (uint8_t)(*p); \
									  p++;\
									  rslt_full = (uint16_t) op1 % op2; \
                                      actual_result[(tn-1)*3 + 0 ] = op1; \
                                      actual_result[(tn-1)*3 + 1 ] = op2; \
                                      actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
					  
// Macro for REM test with spike (C) 
#define REM_TEST_U816EC_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;  \
										  uint8_t op2; \
										  uint16_t rslt_full; \
										  uint16_t rslt_tb; \
										  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint16_t)op1 % op2;\


//////////////////////////////////// Reminder Test uint8_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  

#define REM_TEST_U832_C(mb,op1,op2,rslt_full,tn) \
									  uint32_t op1; \
									  uint8_t op2; \
	                                  uint32_t rslt_full; \
									  op1 = (uint32_t)(*p); \
									  p++;\
									  op2 = (uint8_t)(*p); \
									  p++;\
									  rslt_full = (uint32_t)op1 % op2;\
                               		  actual_result[(tn-1)*3 + 0 ] = op1; \
                                      actual_result[(tn-1)*3 + 1 ] = op2; \
                                      actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					 
// Macro for REM test with spike (C) 
#define REM_TEST_U832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;  \
										  uint8_t op2; \
										  uint32_t rslt_full; \
										  uint32_t rslt_tb; \
										  op1 = (uint32_t)data[(tn-1)*3 + 0  ]; \
										  op2 = (uint8_t)data[(tn-1)*3 + 1]; \
										  rslt_full = (uint32_t)op1 % op2;\
										  rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \       	          

//////////////////////////////////// Reminder Test uint16_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_U1632_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint16_t op2; \
										  uint32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (uint16_t)(*p); \
										  p++;\
										  rslt_full = (uint32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0 ] = op1; \
                                          actual_result[(tn-1)*3 + 1 ] = op2; \
                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;\
					  
// Macro for REM test with spike (C) 
#define REM_TEST_U1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;  \
										  uint16_t op2; \
										  uint32_t rslt_full; \
										  uint32_t rslt_tb; \
										  op1 = (uint32_t)data[(tn-1)*3 + 0  ]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1 ]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2 ]; \
                                          rslt_full = (uint32_t)op1 % op2;\

        //////////////////////////////////// Remainder Test int8_t and int16_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S816_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
										  op1 = (int16_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_S816_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;


//////////////////////////////////// Remainder Test int8_t and int32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S832_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_S832_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 % op2;


//////////////////////////////////// Remainder Test int16_t and int32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S1632_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (C) 
#define REM_TEST_S1632_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 % op2;


        //////////////////////////////////// Remainder Test int8_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S8U8_C(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1;\
										  int8_t op2; \
										  uint8_t rslt_full; \
										  op1 = (uint8_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for REM test with spike (C) 
#define REM_TEST_S8U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint8_t op1;\
										  int8_t op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;


//////////////////////////////////// Remainder Test int16_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S16U16_C(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1;\
										  int16_t op2; \
										  uint16_t rslt_full; \
										  op1 = (uint16_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for REM test with spike (C) 
#define REM_TEST_S16U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint16_t op1;\
										  int16_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;


//////////////////////////////////// Remainder Test int32_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S32U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int32_t op2; \
										  uint32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int32_t)(*p); \
										  p++;\
										  rslt_full = (uint32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for REM test with spike (C) 
#define REM_TEST_S32U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int32_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (uint32_t)op1 % op2;


//////////////////////////////////// Remainder Test int8_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S8U16_C(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1;\
										  int8_t op2; \
										  uint16_t rslt_full; \
										  op1 = (uint16_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for REM test with spike (C) 
#define REM_TEST_S8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint16_t op1;\
										  int8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;


//////////////////////////////////// Remainder Test int8_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S8U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int8_t op2; \
										  uint32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int8_t)(*p); \
										  p++;\
										  rslt_full = (uint32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            
// Macro for REM test with spike (C) 
#define REM_TEST_S8U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (uint32_t)op1 % op2;


//////////////////////////////////// Remainder Test int16_t and uint32_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S16U32_C(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1;\
										  int16_t op2; \
										  uint32_t rslt_full; \
										  op1 = (uint32_t)(*p); \
										  p++;\
                                          op2 = (int16_t)(*p); \
										  p++;\
										  rslt_full = (uint32_t) op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            

// Macro for REM test with spike (C) 
#define REM_TEST_S16U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  uint32_t op1;\
										  int16_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (uint32_t)op1 % op2;


//////////////////////////////////// Remainder Test int16_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S16U8_C(mb,op1,op2,rslt_full,tn) \
										  int16_t op1;\
										  uint8_t op2; \
										  int16_t rslt_full; \
										  op1 = (int16_t)(*p); \
										  p++;\
                                          op2 = (uint8_t)(*p); \
										  p++;\
										  rslt_full = op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

                            
// Macro for REM test with spike (C) 
#define REM_TEST_S16U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int16_t op1;\
										  uint8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 % op2;


// check from here


//////////////////////////////////// Remainder Test int32_t and uint8_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S32U8_C(mb,op1,op2,rslt_full,tn) \
										  int32_t op1;\
										  uint8_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (uint8_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

 
// Macro for REM test with spike (C) 
#define REM_TEST_S32U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int32_t op1;\
										  uint8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 %  op2;


//////////////////////////////////// Remainder Test int32_t and uint16_t MACROs //////////////////////////////////////////*

// Macro for REM test without spike (C)  
#define REM_TEST_S32U16_C(mb,op1,op2,rslt_full,tn) \
										  int32_t op1;\
										  uint16_t op2; \
										  int32_t rslt_full; \
										  op1 = (int32_t)(*p); \
										  p++;\
                                          op2 = (uint16_t)(*p); \
										  p++;\
										  rslt_full = (int32_t)op1 % op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


// Macro for REM test with spike (C) 
#define REM_TEST_S32U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
										  int32_t op1;\
										  uint16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
										  rslt_full = (int32_t)op1 % op2;

////////////////////////////////////////////////////////////////////////////////////////////////////

                            /* Remainder Test Part 4 ( Assembly)*/
///////////////////////////////////////////////////////////////////////////////////////////////////


/* MACROS for REM Test U8U16 */

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  uint8_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _REM_TEST_U8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  uint8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8U16_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases U8U32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_U8U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint8_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _REM_TEST_U8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  uint8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8U32_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases U16U32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_U16U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint16_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
										  _REM_TEST_U16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  uint16_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U16U32_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases S8S16 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S8S16(mb,op1,op2,rslt_full,tn) \
										  int16_t op1; \
										  int8_t op2; \
	                                      int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
										  int8_t op2; \
										  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S8S16_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases S8S32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S8S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  int8_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  int8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S8S32_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases S16S32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S16S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  int16_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _REM_TEST_S16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  int16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S16S32_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases S8U8 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S8U8(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1; \
										  int8_t op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
										  int8_t op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S8U8_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases S16U16 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S16U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  int16_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _REM_TEST_S16U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S16U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  int16_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S16U16_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases S32U32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S32U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int32_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
										  _REM_TEST_S32U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S32U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int32_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S32U32_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases S8U16 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S8U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  int8_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1; \
										  int8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S8U16_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases S8U32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S8U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int8_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _REM_TEST_S8U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S8U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S8U32_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases S16U32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_S16U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  int16_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _REM_TEST_S16U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_S16U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  int16_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_S16U32_(&op1, &op2, &rslt_full);

/* Macros for reminder test cases U8S32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_U8S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  uint8_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _REM_TEST_U8S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  uint8_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8S32_(&op1, &op2, &rslt_full);


/* Macros for reminder test cases U16S32 */

	// Macro for REM test without spike (assembly) 
#define REM_TEST_U16S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  uint16_t op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
										  _REM_TEST_U16S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U16S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  uint16_t op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U16S32_(&op1, &op2, &rslt_full);











//////////////////////////////////////////////// Part 6 ////////////////////////////////////////////




/* Macro for Method 1 max  test without spike (C)  */
//#define REM_TEST_MAXU8U16_C(mb,op1,op2,rslt_full,tn) \
//					  uint16_t op1; \
//					  uint8_t op2; \
//					  uint8_t rslt_full; \
//					  op1 = UINT16_MAX; \
//                                          op2 = UINT8_MAX; \
//				          rslt_full = op1 % op2; \
//                                          actual_result[(tn-1)*3 + 0 ] = op1; \
//                                          actual_result[(tn-1)*3 + 1 ] = op2; \
//                                          actual_result[(tn-1)*3 + 2 ] = rslt_full;
//					  
//					  
///* Macro for Method 1 REM test with spike (C) */
//#define REM_TEST_MAXU8U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
//					  uint16_t op1; \
//					  uint8_t op2; \
//					  uint8_t rslt_full; \
//					  uint8_t rslt_tb; \
//					  op1 = (uint16_t)data[(tn-1)*3 + 0  ]; \
//                      op2 = (uint8_t)data[(tn-1)*3 + 1]; \
//                      rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
//                      rslt_full = (uint8_t)op1 % op2;
//

/* Macro for  method 2 REM test without spike (C)  */
#define REM_TEST_MAX_C(mb,op1,op2,rslt_full,tn ,op1_dt , op2_dt , res_dt ,op1_val , op2_val ) \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  op1 = op1_val; \
                      op2 = op2_val; \
				      rslt_full = op1 % op2; \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro for method 2 REM test with spike (C) */
#define REM_TEST_MAX_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt , op2_dt , res_dt )  \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (op2_dt)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                      rslt_full = op1 % op2;


/* Macro for  method 2 REM MIN test without spike (C)  */
#define REM_TEST_MIN_C(mb,op1,op2,rslt_full,tn ,op1_dt , op2_dt , res_dt ,op1_val , op2_val ) \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  op1 = (op1_dt) op1_val; \
                      op2 = (op2_dt) op2_val; \
				      rslt_full = (res_dt) op1 % op2; \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro for method 2 REM MIN test with spike (C) */
#define REM_TEST_MIN_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt , op2_dt , res_dt )  \
					  op1_dt op1; \
					  op2_dt op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (op2_dt)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \        
                      rslt_full = ( res_dt) op1 % op2;



//////////////////////////////////////  Part5  /////////////////////////

//////////////////////////////////////// Remainder Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////



// Macro for REM test without spike (assembly) 
#define REM_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         				  _REM_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  	  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Remainder Test uint8_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                 	  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          				  _REM_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _REM_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);

//********************************** Remainder Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _REM_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8ZEROSRC1_(&op2, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _REM_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8ZEROSRC2_(&op1, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _REM_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8ZEROSRC12_(&rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _REM_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _REM_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _REM_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Remainder Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Remainder will create result of 16-bit 

// Macro for REM test without spike (assembly) 
#define REM_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _REM_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for REM test with spike (assembly) 
#define REM_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _REM_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);





/////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////    Logical Shift right //////////////////////////////////     
////////////////////////////////////////////////////////////////////////////////////////////////////    


////////////////////////////////////////Logical Shift Right Part 1 /////////////////////////////////
#define SRL_TEST_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
                                          op1_dt op1;\
										  uint8_t op2; \
										  res_dt rslt_full; \
										  res_dt rslt_tb; \
                                          op1 = (op1_dt)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                                          rslt_full = (res_dt)((res_dt)op1 >> op2)

#define SRL_TEST_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt) \
										  op1_dt op1;\
							     		  uint8_t op2; \
										  res_dt rslt_full; \
                                          op1 = (op1_dt)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)((op2 >>3) & (0x1F)); \
										  rslt_full = (res_dt)((res_dt)op1 >> op2);\
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;


//////////////////////////////////////////Logical Right Shift Part 2 Assembly Macros ////////////////////////////
// MAcro for SRl Test without spike 
#define SRL_TEST_U8(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1; \
										  uint8_t op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
                                          _SRL_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1; \
										  uint8_t op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8_(&op1, &op2, &rslt_full);

/////////////////////////int8_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_S8(mb,op1,op2,rslt_full,tn) \
										  int8_t op1; \
										  uint8_t op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1; \
										  uint8_t op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_S8_(&op1, &op2, &rslt_full);



/////////////////////////uint16_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_U16(mb,op1,op2,rslt_full,tn) \
										  uint16_t op1; \
										  uint8_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                         uint16_t op1; \
										  uint8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U16_(&op1, &op2, &rslt_full);



/////////////////////////int16_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_S16(mb,op1,op2,rslt_full,tn) \
										  int16_t op1; \
										  uint8_t op2; \
	                                      uint16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1; \
										  uint8_t op2; \
										  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_S16_(&op1, &op2, &rslt_full);

/////////////////////////int8_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_U32(mb,op1,op2,rslt_full,tn) \
										  uint32_t op1; \
										  uint8_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1; \
										  uint8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U32_(&op1, &op2, &rslt_full);

/////////////////////////int8_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_S32(mb,op1,op2,rslt_full,tn) \
										  int32_t op1; \
										  uint8_t op2; \
	                                      uint32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1; \
										  uint8_t op2; \
										  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_S32_(&op1, &op2, &rslt_full);

/////////////////////////int8_t assembly macro ////////////////////

// MAcro for SRl Test without spike 
#define SRL_TEST_U64(mb,op1,op2,rslt_full,tn) \
										  uint64_t op1; \
										  uint8_t op2; \
	                                      uint64_t rslt_full; \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1; \
										  uint8_t op2; \
										  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U64_(&op1, &op2, &rslt_full);

#define SRL_TEST_S64(mb,op1,op2,rslt_full,tn) \
										  int64_t op1; \
										  uint8_t op2; \
	                                      uint64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
										  _SRL_TEST_S64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1; \
										  uint8_t op2; \
										  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_S64_(&op1, &op2, &rslt_full);



//////////////////////////////////////  Part 3  ////////////////////////////////////////////////////////////////////////

//////////////////////////////////////// Logical Shift Right Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////



// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         				  _SRL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  	  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Logical Shift Right Test uint8_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                 	  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          				  _SRL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _SRL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full);

//********************************** Logical Shift Right Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SRL_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8ZEROSRC1_(&op2, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SRL_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8ZEROSRC2_(&op1, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SRL_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8ZEROSRC12_(&rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SRL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SRL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SRL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Logical Shift Right Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Logical Shift Right will create result of 16-bit 

// Macro for SRL test without spike (assembly) 
#define SRL_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SRL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRL test with spike (assembly) 
#define SRL_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SRL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);


///////////////////////////////////////////////// Macros for Min and MAX cases Part 4 ////////////////////////////////////////


///////////////////////////////////////////////////// macro for max cases/////////////////////////////////////////////////////

#define SRL_TEST_MAX_C(mb,op1,op2,rslt_full,tn ,op1_dt, res_dt ,op1_val, op2_val ) \
					  op1_dt op1; \
					  uint8_t op2; \
					  res_dt rslt_full; \
					  op1 = op1_val; \
                      op2 = op2_val ; \
					  rslt_full = (res_dt)((res_dt)op1 >> op2); \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro max SRL test with spike (C) */
#define SRL_TEST_MAX_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt  , res_dt )  \
					  op1_dt op1; \
					  uint8_t op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                      rslt_full = (res_dt)((res_dt)op1 >> op2);

#define SRL_TEST_MIN_C(mb,op1,op2,rslt_full,tn ,op1_dt, res_dt ,op1_val, op2_val ) \
					  op1_dt op1; \
					  uint8_t op2; \
					  res_dt rslt_full; \
					  op1 = op1_val; \
                      op2 = op2_val ; \
					  rslt_full = (res_dt)((res_dt)op1 >> op2); \
                      actual_result[(tn-1)*3 + 0 ] = op1; \
                      actual_result[(tn-1)*3 + 1 ] = op2; \
                      actual_result[(tn-1)*3 + 2 ] = rslt_full;
					  
					  
/* Macro MIN SRL test with spike (C) */
#define SRL_TEST_MIN_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn , op1_dt  , res_dt )  \
					  op1_dt op1; \
					  uint8_t op2; \
					  res_dt rslt_full; \
					  res_dt rslt_tb; \
					  op1 = (op1_dt)data[(tn-1)*3 + 0  ]; \
                      op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                      rslt_tb = (res_dt)data[(tn-1)*3 + 2]; \
                      rslt_full = (res_dt)((res_dt)op1 >> op2);


//////////////////////////////////////Logical shift Right immediate macro /////////////////////////////////
#define TEST_SRLI_INSN_I(mb, insn, op1, imm, result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SRLI_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt)data[(tn-1)*3 + 0]; \
                op2        =(uint8_t)data[(tn-1)*3 + 1]; \
		        result     =(res_dt)data[(tn-1)*3 + 2]; \
	            asm volatile (srl_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ;

//////////////////////////////////////Logical shift Right immediate macro (srlw)/////////////////////////////////
#define TEST_SRLIW_INSN_I(mb, insn, op1, imm, result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SRLIW_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt) data[(tn-1)*3 + 0]; \
                op2        =(uint8_t) data[(tn-1)*3 + 1]; \
		        result     =(res_dt) data[(tn-1)*3 + 2]; \
	            asm volatile (srlw_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 



///////////////////////////////////////////// Immediate - SRL min and max macros //////////////////////////////////////

//////////////////////////////////////immediate logical shift right immediate macro (s)/////////////////////////////////
#define TEST_MAX_MIN_SRLIW_INSN_I( insn, op1, op2, result, tn , op1_dt , res_dt, op1_val, imm) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)op1_val; \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test (SPIKE) 
#define TEST_MAX_MIN_SRLIW_INSN_I_SPIKE(insn, op1, op2,result, exp_result, tn ,  op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt) data[(tn-1)*3 + 0]; \
                op2        =(uint8_t) data[(tn-1)*3 + 1]; \
		        result     =(res_dt) data[(tn-1)*3 + 2]; \
	            asm volatile (srlw_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 

//////////////////////////////////////Logical shift Right immediate macro SRLI /////////////////////////////////
#define TEST_MAX_MIN_SRLI_INSN_I( insn, op1, op2, result, tn , op1_dt , res_dt, op1_val, imm) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)op1_val; \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_MAX_MIN_SRLI_INSN_I_SPIKE(insn, op1, op2,result, exp_result, tn ,  op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt)data[(tn-1)*3 + 0]; \
                op2        =(uint8_t)data[(tn-1)*3 + 1]; \
		        result     =(res_dt)data[(tn-1)*3 + 2]; \
	            asm volatile (srl_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ;

///////////////////////////////////////////////////////////////////////////////////////////
//


////////////////////////****************************Set less than macros**********************/////////////////////////
/////////////////////////////Set less than uint8_t macros/////////////////////////////
/// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8_(&op1, &op2, &rslt_full);

// Macro for SLTU test without spike (C) 
#define SLTU_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (C) 
#define SLTU_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 < op2;


//////////////////////////////////// Set less than  Test int8 MACROS//////////////////////////////

//Macro for int8 Set less than  without spike(c)

#define SLT_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  rslt_full = op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

//MACRO for int8 Set less than  with spike(c) 

#define SLT_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 < op2;
// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _SLT_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
										  int8_t rslt_tb; \
										  op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  _SLT_TEST_S8_(&op1, &op2, &rslt_full);
                      

//////////////////////////////////// Set less than   Test uint16_t MACROs ///////////////////////////////////////////
// Macro for SLTU test without spike (C) 
#define SLTU_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLTU test with spike (C) 
#define SLTU_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
										  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 < op2;

      // Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _SLTU_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U16_(&op1, &op2, &rslt_full);


//////////////////////////////////// Set less than   Test int16_t MACROs ///////////////////////////////////////////

// Macro for SLT test without spike (C) 
#define SLT_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          rslt_full = op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLT test with spike (C) 
#define SLT_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
										  int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 < op2;

 // Macro for SLT test without spike (assembly) 
#define SLT_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _SLT_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S16_(&op1, &op2, &rslt_full);


//////////////////////////////////// Set less than Test uint32_t MACROs ///////////////////////////////////////////


// Macro for SLTU test without spike (C) 
#define SLTU_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint32_t)op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (C) 
#define SLTU_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 < op2;
 // Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SLTU_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U32_(&op1, &op2, &rslt_full);

                      
//////////////////////////////////// Set less than Test int32_t MACROs ///////////////////////////////////////////


// Macro for SLT test without spike (C) 
#define SLT_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int32_t)op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (C) 
#define SLT_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                           rslt_full = (int32_t)op1 < op2;
// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SLT_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                       _SLT_TEST_S32_(&op1, &op2, &rslt_full);
				          

//////////////////////////////////// Set less than Test uint64_t MACROs ///////////////////////////////////////////


// Macro for SLTU test without spike (C) 
#define SLTU_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (C) 
#define SLTU_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 < op2;
 // Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U64(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _SLTU_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U64_(&op1, &op2, &rslt_full);

                      
//////////////////////////////////// Set less than Test int64_t MACROs ///////////////////////////////////////////


// Macro for SLT test without spike (C) 
#define SLT_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 < op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (C) 
#define SLT_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                           rslt_full = (int64_t)op1 < op2;
// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S64(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _SLT_TEST_S64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                       _SLT_TEST_S64_(&op1, &op2, &rslt_full);
				          

///////////////////////////////////////////////part 3/////////////////////////////////////
/////////////////////////////////////SLTU COMPLAINCE TEST/////////////////////////////////////////////



/***************************** Set less than Test uint8_t TEST_RR_SRC1_EQ_DEST *****************************************/



// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         				  _SLTU_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  	  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Set less than Test uint8_t TEST_RR_SRC2_EQ_DEST******************************************/
// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                 	  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          				  _SLTU_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);

//********************************** Set less than Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _SLTU_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); 

//********************************** Set less than Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8ZEROSRC1_(&op2, &rslt_full); 


//********************************** Set less than Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SLTU_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8ZEROSRC2_(&op1, &rslt_full); 


//********************************** Set less than Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SLTU_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8ZEROSRC12_(&rslt_full); 


//********************************** Set less than Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); 


//********************************** Set less than Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); 


//********************************** Set less than Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Set less than Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Set less than will create result of 8-bit 

// Macro for SLTU test without spike (assembly) 
#define SLTU_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLTU_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLTU test with spike (assembly) 
#define SLTU_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLTU_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);


////////////////////////COMPLIANCE TEST //////////////////////////////
 
//////////////////////////////////////// Set less than Test int32_t TEST_RR_SRC1_EQ_DEST /////////////////////////



// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  int32_t op1, op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				         				  _SLT_TEST_S32SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  	  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Set less than Test int32_t TEST_RR_SRC2_EQ_DEST******************************************/
// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  int32_t op1, op2; \
	                                 	  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          				  _SLT_TEST_S32SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                      int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32SRC2_EQ_DEST_(&op1, &op2, &rslt_full);

//********************************** Set less than Test int32_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  int32_t op1, op2; \
	                                      int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _SLT_TEST_S32SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
										  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32SRC12_EQ_DEST_(&op1, &rslt_full); 

//********************************** Set less than Test int32_t TEST_RR_ZEROSRC1*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SLT_TEST_S32ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32ZEROSRC1_(&op2, &rslt_full); 


//********************************** Set less than Test int32_t TEST_RR_ZEROSRC2*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SLT_TEST_S32ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32ZEROSRC2_(&op1, &rslt_full); 


//********************************** Set less than Test int32_t TEST_RR_ZEROSRC12*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SLT_TEST_S32ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32ZEROSRC12_(&rslt_full); 


//********************************** Set less than Test int32_t TEST_RR_ZERODEST*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32ZERODEST(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SLT_TEST_S32ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32ZERODEST_(&op1, &op2, &rslt_full); 


//********************************** Set less than Test int32_t TEST_RR_DEST_BYPASS*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SLT_TEST_S32DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32DEST_BYPASS_(&op1, &op2, &rslt_full); 


//********************************** Set less than Test int32_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SLT_TEST_S32SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Set less than Test int32_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 32-bit operand Set less than will create result of 32-bit 

// Macro for SLT test without spike (assembly) 
#define SLT_TEST_S32SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
				          _SLT_TEST_S32SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLT test with spike (assembly) 
#define SLT_TEST_S32SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                          _SLT_TEST_S32SRC21_BYPASS_(&op1, &op2, &rslt_full);




//////////////////////////////////////////////////////PART 5/////////////////////////////////////////////////////////
///////////////////////////////////MIN AND MAX TEST CASES//////////////////////////////////////////////////



/*********************************** Set less than Test int8_t and int8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand Set less than will create result of 8-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MAXS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = INT8_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MAXS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less tha Test int16_t and int16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand Set less than will create result of 16-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MAXS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = INT16_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MAXS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test int32_t and int32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand Set less than will create result of 32-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MAXS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT32_MAX; \ 
                                          op2 = INT32_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full; 

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MAXS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;

/********************************************Set less than test int64_t and int 64_t MACROS***********************************/
/* Note: MAX of 64-bi toperand and 64-bit operand Set less than will create result of 64-bit*/

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MAXS6464_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT64_MAX; \
                                          op2 = INT64_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MAXS6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;




/*********************************** Set less than Test uint8_t and uint8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand Set less than will create result of 8-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MAXU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
					  op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MAXU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test uint16_t and uint16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand Set less than will create result of 16-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MAXU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
					  op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MAXU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test uint32_t and uint32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand Set less than will create result of 32-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MAXU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MAXU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


   
/*********************************** Set less than Test uint64_t and uint64_t MACROs ********************************************/

/* Note: MAX of 64-bi toperand and 64-bit operand Set less than will create result of 64-bit*/

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MAXU6464_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MAXU6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;








/*********************************** Set less than Test int8_t and int8_t MACROs ********************************************/

/* Note: MIN of 8-bit operand and 8-bit operand Set less than will create result of 8-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MINS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = INT8_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MINS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less tha Test int16_t and int16_t MACROs ********************************************/

/* Note: MIN of 16-bit operand and 16-bit operand Set less than will create result of 16-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MINS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = INT16_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MINS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test int32_t and int32_t MACROs ********************************************/

/* Note: MIN of 32-bit operand and 32-bit operand Set less than will create result of 32-bit */

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MINS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1; \
					                  int32_t op2;  \
	                              int32_t rslt_full; \ 
					                     op1 = INT32_MIN; \
                                        op2 = INT32_MIN; \
				                        rslt_full = op1 <  op2; \
                                        actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full; 

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MINS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;

/********************************************Set less than test int64_t and int 64_t MACROS***********************************/
/* Note: MIN of 64-bi toperand and 64-bit operand Set less than will create result of 64-bit*/

/* Macro for SLT test without spike (C)  */
#define SLT_TEST_MINS6464_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT64_MIN; \
                                          op2 = INT64_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLT test with spike (C) */
#define SLT_TEST_MINS6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;




/*********************************** Set less than Test uint8_t and uint8_t MACROs ********************************************/

/* Note: MIN of 8-bit operand and 8-bit operand Set less than will create result of 8-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MINU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
					  op1 = UINT8_MIN; \
                                          op2 = UINT8_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MINU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test uint16_t and uint16_t MACROs ********************************************/

/* Note: MIN of 16-bit operand and 16-bit operand Set less than will create result of 16-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MINU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
					  op1 = UINT16_MIN; \
                                          op2 = UINT16_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MINU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


/*********************************** Set less than Test uint32_t and uint32_t MACROs ********************************************/

/* Note: MIN of 32-bit operand and 32-bit operand Set less than will create result of 32-bit */

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MINU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT32_MIN; \
                                          op2 = UINT32_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MINU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;


   
/*********************************** Set less than Test uint64_t and uint64_t MACROs ********************************************/

/* Note: MIN of 64-bi toperand and 64-bit operand Set less than will create result of 64-bit*/

/* Macro for SLTU test without spike (C)  */
#define SLTU_TEST_MINU6464_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT64_MIN; \
                                          op2 = UINT64_MIN; \
				          rslt_full = op1 <  op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLTU test with spike (C) */
#define SLTU_TEST_MINU6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 <  op2;




//////////////////////////////////////Set less than immediate macro /////////////////////////////////
#define TEST_SLTI_INSN_I(mb, insn, op1, imm, result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                op1_dt op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile(#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SLTI_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                op1_dt op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt)data[(tn-1)*3 + 0]; \
                op2        =(op1_dt)data[(tn-1)*3 + 1]; \
		        result     =(res_dt)data[(tn-1)*3 + 2]; \
	            asm volatile(slti_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ;

//////////////////////////////////////Set less than immediate unsigned macro /////////////////////////////////
#define TEST_SLTIU_INSN_I(mb, insn, op1, imm, result, tn , op1_dt ,res_dt) \
		        op1_dt op1; \
                op1_dt op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile(#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SLTIU_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt, res_dt) \
		        op1_dt op1; \
                op1_dt op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt) data[(tn-1)*3 + 0]; \
                op2        =(op1_dt) data[(tn-1)*3 + 1]; \
		        result     =(res_dt) data[(tn-1)*3 + 2]; \
	            asm volatile(sltiu_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 




/////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////    Logical Shift left //////////////////////////////////     
////////////////////////////////////////////////////////////////////////////////////////////////////    


////////////////////////****************************Left shift macros**********************/////////////////////////
/// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8_(&op1, &op2, &rslt_full);

// Macro for SLL test without spike (C) 
#define SLL_TEST_U8_C(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (C) 
#define SLL_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
					  uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 << op2;


//////////////////////////////////// Shift left Test int8 MACROS//////////////////////////////

//Macro for int8 Shift left without spike(c)

#define SLL_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

//MACRO for int8 Shift left with spike(c) 

#define SLL_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  rslt_full = op1 << op2;
// Macro for SLL test without spike (assembly) 
#define SLL_TEST_S8(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
                                          op1 = (int8_t)generate_random_num(mb); \
                                          op2 = (int8_t)generate_random_num(mb); \
										  _SLL_TEST_S8_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1, op2; \
										  int8_t rslt_full; \
										  int8_t rslt_tb; \
										  op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
										  _SLL_TEST_S8_(&op1, &op2, &rslt_full);
                      

//////////////////////////////////// Shift left  Test uint16_t MACROs ///////////////////////////////////////////
// Macro for SLL test without spike (C) 
#define SLL_TEST_U16_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLL test with spike (C) 
#define SLL_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
										  uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 << op2;

      // Macro for SLL test without spike (assembly) 
#define SLL_TEST_U16(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          op1 = (uint16_t)generate_random_num(mb); \
                                          op2 = (uint16_t)generate_random_num(mb); \
                                          _SLL_TEST_U16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1, op2; \
                                          uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U16_(&op1, &op2, &rslt_full);


//////////////////////////////////// Shift left  Test int16_t MACROs ///////////////////////////////////////////

// Macro for SLL test without spike (C) 
#define SLL_TEST_S16_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
                                          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;
				          

// Macro for SLL test with spike (C) 
#define SLL_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
										  int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = op1 << op2;

 // Macro for SLL test without spike (assembly) 
#define SLL_TEST_S16(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          op1 = (int16_t)generate_random_num(mb); \
                                          op2 = (int16_t)generate_random_num(mb); \
										  _SLL_TEST_S16_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1, op2; \
                                          int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_S16_(&op1, &op2, &rslt_full);

//////////////////////////////////// Shift left Test uint32_t MACROs ///////////////////////////////////////////


// Macro for SLL test without spike (C) 
#define SLL_TEST_U32_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          rslt_full = (uint32_t)op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (C) 
#define SLL_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint32_t)op1 << op2;
 // Macro for SLL test without spike (assembly) 
#define SLL_TEST_U32(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
                                          _SLL_TEST_U32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2;  \
                                          uint32_t rslt_full;  \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U32_(&op1, &op2, &rslt_full);

                      
//////////////////////////////////// Shift left Test int32_t MACROs ///////////////////////////////////////////


// Macro for SLL test without spike (C) 
#define SLL_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          rslt_full = (int32_t)op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (C) 
#define SLL_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                           rslt_full = (int32_t)op1 << op2;
// Macro for SLL test without spike (assembly) 
#define SLL_TEST_S32(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          op1 = (int32_t)generate_random_num(mb); \
                                          op2 = (int32_t)generate_random_num(mb); \
                                          _SLL_TEST_S32_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1, op2; \
                                          int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (int32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
                                       _SLL_TEST_S32_(&op1, &op2, &rslt_full);
				          

//////////////////////////////////// Shift left Test uint64_t MACROs ///////////////////////////////////////////


// Macro for SLL test without spike (C) 
#define SLL_TEST_U64_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          rslt_full = (uint64_t)op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (C) 
#define SLL_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
                                          rslt_full = (uint64_t)op1 << op2;
 // Macro for SLL test without spike (assembly) 
#define SLL_TEST_U64(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          op1 = (uint64_t)generate_random_num(mb); \
                                          op2 = (uint64_t)generate_random_num(mb); \
                                          _SLL_TEST_U64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1, op2;  \
                                          uint64_t rslt_full;  \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U64_(&op1, &op2, &rslt_full);

                      
//////////////////////////////////// Shift left Test int64_t MACROs ///////////////////////////////////////////


// Macro for SLL test without spike (C) 
#define SLL_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          rslt_full = (int64_t)op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (C) 
#define SLL_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                           rslt_full = (int64_t)op1 << op2;
// Macro for SLL test without spike (assembly) 
#define SLL_TEST_S64(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          op1 = (int64_t)generate_random_num(mb); \
                                          op2 = (int64_t)generate_random_num(mb); \
                                          _SLL_TEST_S64_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1, op2; \
                                          int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
                                       _SLL_TEST_S64_(&op1, &op2, &rslt_full);
				          








//////////////////////////////////////  Part3  //////////////////////////////////
////////////////////////COMPLIANCE TEST //////////////////////////////
 
//////////////////////////////////////// Shift left Test uint8_t TEST_RR_SRC1_EQ_DEST /////////////////////////



// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				         				  _SLL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  	  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8SRC1_EQ_DEST_(&op1, &op2, &rslt_full);



/********************************** Shift left Test uint8_t TEST_RR_SRC2_EQ_DEST******************************************/
// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
										  uint8_t op1, op2; \
	                                 	  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          				  _SLL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8SRC2_EQ_DEST_(&op1, &op2, &rslt_full);

//********************************** Shift left Test uint8_t TEST_RR_SRC12_EQ_DEST*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  					  uint8_t op1, op2; \
	                                      uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = op1; \
				                         _SLL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
										  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8SRC12_EQ_DEST_(&op1, &rslt_full); 

//********************************** Shift left Test uint8_t TEST_RR_ZEROSRC1*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8ZEROSRC1_(&op2, &rslt_full); 


//********************************** Shift left Test uint8_t TEST_RR_ZEROSRC2*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SLL_TEST_U8ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8ZEROSRC2_(&op1, &rslt_full); 


//********************************** Shift left Test uint8_t TEST_RR_ZEROSRC12*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SLL_TEST_U8ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8ZEROSRC12_(&rslt_full); 


//********************************** Shift left Test uint8_t TEST_RR_ZERODEST*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); 


//********************************** Shift left Test uint8_t TEST_RR_DEST_BYPASS*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); 


//********************************** Shift left Test uint8_t TEST_RR_SRC12_BYPASS*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);


//********************************** Shift left Test uint8_t TEST_RR_SRC21_BYPASS*******************************************

// Note: 8-bit operand Shift left will create result of 16-bit 

// Macro for SLL test without spike (assembly) 
#define SLL_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          op1 = (uint8_t)generate_random_num(mb); \
                                          op2 = (uint8_t)generate_random_num(mb); \
				          _SLL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLL test with spike (assembly) 
#define SLL_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1, op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
                                          _SLL_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);


                         
                         
 //////////////////////////////////////  Part4  //////////////////////////////////
////////////////////////COMPLIANCE TEST //////////////////////////////
//////////////////////////////////////// SLLW Test uint32_t TEST_RR_SRC1_EQ_DEST /////////////////////////

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32SRC1_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_SRC2_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32SRC2_EQ_DEST_(&op1, &op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_SRC12_EQ_DEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = op1; \
				          _SLLW_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32SRC12_EQ_DEST_(&op1, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_ZEROSRC1*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32ZEROSRC1(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32ZEROSRC1_(&op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32ZEROSRC1_(&op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_ZEROSRC2*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32ZEROSRC2(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = 0; \
				          _SLLW_TEST_U32ZEROSRC2_(&op1, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32ZEROSRC2_(&op1, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_ZEROSRC12*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32ZEROSRC12(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = 0; \
                                          op2 = 0; \
				          _SLLW_TEST_U32ZEROSRC12_(&rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32ZEROSRC12_(&rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_ZERODEST*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32ZERODEST(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32ZERODEST_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32ZERODEST_(&op1, &op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_DEST_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32DEST_BYPASS_(&op1, &op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_SRC12_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32SRC12_BYPASS_(&op1, &op2, &rslt_full);


/********************************** SLLW Test uint32_t TEST_RR_SRC21_BYPASS*******************************************/

// Note: 32-bit operand and will create result of 32-bit 

// Macro for SLLW test without spike (assembly) 
#define SLLW_TEST_U32SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
					  uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          op1 = (uint32_t)generate_random_num(mb); \
                                          op2 = (uint32_t)generate_random_num(mb); \
				          _SLLW_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full); \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SLLW test with spike (assembly) 
#define SLLW_TEST_U32SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1, op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
                                          _SLLW_TEST_U32SRC21_BYPASS_(&op1, &op2, &rslt_full);
   


//////////////////////////////////////////////////////PART 5/////////////////////////////////////////////////////////
///////////////////////////////////MIN AND MAX TEST CASES//////////////////////////////////////////////////



/*********************************** Shift left Test int8_t and int8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand Shift left will create result of 8-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
					  op1 = INT8_MAX; \
                                          op2 = INT8_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift leftTest int16_t and int16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand Shift left will create result of 16-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
					  op1 = INT16_MAX; \
                                          op2 = INT16_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test int32_t and int32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand Shift left will create result of 32-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT32_MAX; \
                                          op2 = INT32_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full; 

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;

/********************************************Shift left test int64_t and int 64_t MACROS***********************************/
/* Note: MAX of 64-bi toperand and 64-bit operand Shift left will create result of 64-bit*/

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXS6464_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT64_MAX; \
                                          op2 = INT64_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXS6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;




/*********************************** Shift left Test uint8_t and uint8_t MACROs ********************************************/

/* Note: Max of 8-bit operand and 8-bit operand Shift left will create result of 8-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
					  op1 = UINT8_MAX; \
                                          op2 = UINT8_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test uint16_t and uint16_t MACROs ********************************************/

/* Note: Max of 16-bit operand and 16-bit operand Shift left will create result of 16-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
					  op1 = UINT16_MAX; \
                                          op2 = UINT16_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test uint32_t and uint32_t MACROs ********************************************/

/* Note: Max of 32-bit operand and 32-bit operand Shift left will create result of 32-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT32_MAX; \
                                          op2 = UINT32_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


   
/*********************************** Shift left Test uint64_t and uint64_t MACROs ********************************************/

/* Note: MAX of 64-bi toperand and 64-bit operand Shift left will create result of 64-bit*/

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MAXU6464_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT64_MAX; \
                                          op2 = UINT64_MAX; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MAXU6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;




/*********************************** Shift left Test int8_t and int8_t MACROs ********************************************/

/* Note: MIN of 8-bit operand and 8-bit operand Shift left will create result of 8-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINS88_C(mb,op1,op2,rslt_full,tn) \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
					  op1 = INT8_MIN; \
                                          op2 = INT8_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINS88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int8_t op1;\
					  int8_t op2; \
	                                  int8_t rslt_full; \
                                          int8_t rslt_tb; \
                                          op1 = (int8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test int16_t and int16_t MACROs ********************************************/

/* Note: MIN of 16-bit operand and 16-bit operand Shift left will create result of 16-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINS1616_C(mb,op1,op2,rslt_full,tn) \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
					  op1 = INT16_MIN; \
                                          op2 = INT16_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINS1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int16_t op1;\
					  int16_t op2; \
	                                  int16_t rslt_full; \
                                          int16_t rslt_tb; \
                                          op1 = (int16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test int32_t and int32_t MACROs ********************************************/

/* Note: MIN of 32-bit operand and 32-bit operand Shift left will create result of 32-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINS3232_C(mb,op1,op2,rslt_full,tn) \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
					  op1 = INT32_MIN; \
                                          op2 = INT32_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINS3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int32_t op1;\
					  int32_t op2; \
	                                  int32_t rslt_full; \
                                          int32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;

/*********************************** Shift left Test int64_t and int64_t MACROs ********************************************/

/* Note: MIN of 64-bi toperand and 64-bit operand Shift left will create result of 64-bit*/

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINS6464_C(mb,op1,op2,rslt_full,tn) \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
					  op1 = INT64_MIN; \
                                          op2 = INT64_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINS6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          int64_t op1;\
					  int64_t op2; \
	                                  int64_t rslt_full; \
                                          int64_t rslt_tb; \
                                          op1 = (int64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (int64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;




/*********************************** Shift left Test uint8_t and uint8_t MACROs ********************************************/

/* Note: MIN of 8-bit operand and 8-bit operand Shift left will create result of 8-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINU88_C(mb,op1,op2,rslt_full,tn) \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
					  op1 = UINT8_MIN; \
                                          op2 = UINT8_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINU88_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint8_t op1;\
					  uint8_t op2; \
	                                  uint8_t rslt_full; \
                                          uint8_t rslt_tb; \
                                          op1 = (uint8_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint8_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test uint16_t and uint16_t MACROs ********************************************/

/* Note: MIN of 16-bit operand and 16-bit operand Shift left will create result of 16-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINU1616_C(mb,op1,op2,rslt_full,tn) \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
					  op1 = UINT16_MIN; \
                                          op2 = UINT16_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINU1616_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint16_t op1;\
					  uint16_t op2; \
	                                  uint16_t rslt_full; \
                                          uint16_t rslt_tb; \
                                          op1 = (uint16_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint16_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test uint32_t and uint32_t MACROs ********************************************/

/* Note: MIN of 32-bit operand and 32-bit operand Shift left will create result of 32-bit */

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINU3232_C(mb,op1,op2,rslt_full,tn) \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
					  op1 = UINT32_MIN; \
                                          op2 = UINT32_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINU3232_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint32_t op1;\
					  uint32_t op2; \
	                                  uint32_t rslt_full; \
                                          uint32_t rslt_tb; \
                                          op1 = (uint32_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint32_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;

/*********************************** Shift left Test uint64_t and uint64_t MACROs ********************************************/

/* Note: MIN of 64-bi toperand and 64-bit operand Shift left will create result of 64-bit*/

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINU6464_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT64_MIN; \
                                          op2 = UINT64_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINU6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;


/*********************************** Shift left Test uint64_t and uint64_t MACROs ********************************************/

/* Note: MIN of 64-bi toperand and 64-bit operand Shift left will create result of 64-bit*/

/* Macro for SLL test without spike (C)  */
#define SLL_TEST_MINU6464_C(mb,op1,op2,rslt_full,tn) \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
					  op1 = UINT64_MIN; \
                                          op2 = UINT64_MIN; \
				          rslt_full = op1 << op2; \
                                          actual_result[(tn-1)*3 + 0] = op1; \
                                          actual_result[(tn-1)*3 + 1] = op2; \
                                          actual_result[(tn-1)*3 + 2] = rslt_full;

/* Macro for SLL test with spike (C) */
#define SLL_TEST_MINU6464_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
                                          uint64_t op1;\
					  uint64_t op2; \
	                                  uint64_t rslt_full; \
                                          uint64_t rslt_tb; \
                                          op1 = (uint64_t)data[(tn-1)*3 + 0]; \
                                          op2 = (uint64_t)data[(tn-1)*3 + 1]; \
                                          rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
					  rslt_full = op1 << op2;



//////////////////////////////////////Logical shift left immediate macro /////////////////////////////////
#define TEST_SLLI_INSN_I(mb, insn, op1, imm, result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SLLI_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt)data[(tn-1)*3 + 0]; \
                op2        =(uint8_t)data[(tn-1)*3 + 1]; \
		        result     =(res_dt)data[(tn-1)*3 + 2]; \
	            asm volatile (sll_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ;

//////////////////////////////////////Logical shift left immediate macro (sllw)/////////////////////////////////
#define TEST_SLLIW_INSN_I(mb, insn, op1, imm, result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
                op1 = (op1_dt)generate_random_num(mb); \
                op2 = imm; \
		        asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op2; \
                actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SLLIW_INSN_I_SPIKE(insn, op1, imm, result, exp_result, tn , op1_dt , res_dt) \
		        op1_dt op1; \
                uint8_t op2; \
	            res_dt result; \
	        	res_dt exp_result; \
                op1        =(op1_dt) data[(tn-1)*3 + 0]; \
                op2        =(uint8_t) data[(tn-1)*3 + 1]; \
		        result     =(res_dt) data[(tn-1)*3 + 2]; \
	            asm volatile (sllw_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 

/************************************************************************************************************************
********                                                                                                      ***********                                          
********                          Test Macros for Shift Right Arithmatic Operation                            ***********
********                                                                                                      ***********
************************************************************************************************************************/


//******************************   PART 1 : C TEST    ************************************
//******************        SRAW test for uint8_t Macros       ****************************

//Macros for SRAW test with spike 
#define SRA_TEST_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t     op1; \
    uint8_t     op2; \
    uint8_t     rslt_full;  \
    uint8_t     rslt_tb; \
    op1       = (uint8_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (uint8_t)data[(tn-1)*3 + 2]; \
	rslt_full = (int8_t)op1 >> op2;

//Macros for SRA test without spike
#define SRA_TEST_U8_C(mb,op1,op2,rslt_full,tn)   \
    uint8_t     op1; \
    uint8_t     op2; \
    uint8_t     rslt_full; \
    op1       = (uint8_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = (int8_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//********************         SRAW Test for int8_t Macros      ***************************

//Macros for SRAW test with Spike
#define SRA_TEST_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    int8_t      op1; \
    uint8_t     op2; \
    int8_t      rslt_full; \
    int8_t      rslt_tb; \
    op1       = (int8_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (int8_t)data[(tn-1)*3 + 2]; \
	rslt_full = op1 >> op2;

//Macros for SRA test without Spike
#define SRA_TEST_S8_C(mb,op1,op2,rslt_full,tn) \
    int8_t      op1; \
    uint8_t     op2; \
    int8_t      rslt_full; \
    op1       = (int8_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//**************    SRAW test for uint16_t Macros    *************************

//Macros for SRAW test with spike
#define SRA_TEST_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    uint16_t    op1; \
    uint8_t     op2; \
    uint16_t    rslt_full; \
    uint16_t    rslt_tb; \
    op1       = (uint16_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (uint16_t)data[(tn-1)*3 + 2]; \
	rslt_full = (int16_t)op1 >> op2;

//Macros for SRA test without spike
#define SRA_TEST_U16_C(mb,op1,op2,rslt_full,tn)   \
    uint16_t    op1; \
    uint8_t     op2; \
    uint16_t    rslt_full; \
    op1       = (uint16_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = (int16_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRAW Test for int16_t Macros    *********************************

//Macros for SRAW test with Spike
#define SRA_TEST_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    int16_t     op1; \
    uint8_t     op2; \
    int16_t     rslt_full; \
    int16_t     rslt_tb; \
    op1       = (int16_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (int16_t)data[(tn-1)*3 + 2]; \
	rslt_full = op1 >> op2;

//Macros for SRAW test without Spike
#define SRA_TEST_S16_C(mb,op1,op2,rslt_full,tn)  \
    int16_t     op1; \
    uint8_t     op2; \
    int16_t     rslt_full; \
    op1       = (int16_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//********************** SRAW test for uint32_t Macros  **********************************

//Macros for SRAW test with spike
#define SRA_TEST_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    uint32_t    op1; \
    uint8_t     op2; \
    uint32_t    rslt_full; \
    uint32_t    rslt_tb; \
    op1       = (uint32_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (uint32_t)data[(tn-1)*3 + 2]; \
	rslt_full = (int32_t)op1 >> op2;

//Macros for SRAW test without spike
#define SRA_TEST_U32_C(mb,op1,op2,rslt_full,tn)   \
    uint16_t    op1; \
    uint8_t     op2; \
    uint16_t    rslt_full; \
    op1       = (uint32_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = (int32_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRAW Test for int32_t Macros    *********************************

//Macros for SRAW test with Spike
#define SRA_TEST_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    int32_t     op1; \
    uint8_t     op2; \
    int32_t     rslt_full; \
    int32_t     rslt_tb; \
    op1       = (int32_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (int32_t)data[(tn-1)*3 + 2]; \
	rslt_full = op1 >> op2;

//Macros for SRAW test without Spike
#define SRA_TEST_S32_C(mb,op1,op2,rslt_full,tn) \
    int32_t     op1; \
    uint8_t     op2; \
    int32_t     rslt_full; \
    op1       = (int32_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//********************** SRA test for uint64_t Macros  **********************************

//Macros for SRA test with Spike
#define SRAW_TEST_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    uint64_t    op1; \
    uint8_t     op2; \
    uint64_t    rslt_full; \
    uint64_t    rslt_tb; \
    op1       = (uint64_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (uint64_t)data[(tn-1)*3 + 2]; \
	rslt_full = (int64_t)op1 >> op2;

//Macros for SRA test without Spike
#define SRAW_TEST_U64_C(mb,op1,op2,rslt_full,tn)  \
    uint64_t    op1; \
    uint8_t     op2; \
    uint64_t    rslt_full; \
    op1       = (uint64_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = (int64_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRA Test for int64_t Macros    *********************************
   
//Macros for SRA test with Spike
#define SRAW_TEST_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn)  \
    int64_t     op1; \
    uint8_t     op2; \
    int64_t     rslt_full; \
    int64_t     rslt_tb; \
    op1       = (int64_t)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (int64_t)data[(tn-1)*3 + 2]; \
	rslt_full = op1 >> op2;

//Macros for SRA test without Spike
#define SRAW_TEST_S64_C(mb,op1,op2,rslt_full,tn) \
    int64_t     op1; \
    uint8_t     op2; \
    int64_t     rslt_full; \
    op1       = (int64_t)generate_random_num(mb); \
    op2       = (uint8_t)generate_random_num(mb); \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;



//******************************   PART 2 : ASSEMBLY CODE TEST    ************************************
//********************** SRAW test for uint8_t Macros  **********************************

//Macros for SRA test with spike 
#define SRA_TEST_U8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1; \
    uint8_t   op2; \
	uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8_(&op1, &op2, &rslt_full);


//Macros for SRA test without spike
#define SRA_TEST_U8(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1; \
    uint8_t  op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
	_SRA_TEST_U8_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;
    

//**********    SRAW Test for int8_t Macros    *********************   

//Macros for SRAW test with Spike
#define SRA_TEST_S8_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    int8_t    op1; \
    uint8_t   op2; \
	int8_t    rslt_full; \
	int8_t    rslt_tb; \
	op1     = (int8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (int8_t)data[(tn-1)*3 + 2]; \
	_SRA_TEST_S8_(&op1, &op2, &rslt_full); 

//Macros for SRA test without Spike
#define SRA_TEST_S8(mb,op1,op2,rslt_full,tn) \
    int8_t   op1; \
    uint8_t  op2; \
	int8_t   rslt_full; \
    op1    = (int8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
	_SRA_TEST_S8_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;


//**************    SRAW test for uint16_t Macros    *************************

//Macros for SRAW test with spike
#define SRA_TEST_U16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint16_t  op1;  \
    uint8_t   op2;  \
    uint16_t  rslt_full; \
    uint16_t  rslt_tb; \
    op1     = (uint16_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint16_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U16_(&op1, &op2, &rslt_full);


//Macros for SRA test without spike
#define SRA_TEST_U16(mb,op1,op2,rslt_full,tn) \
    uint16_t  op1;  \
    uint8_t   op2; \
    uint16_t  rslt_full; \
    op1     = (uint16_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U16_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRA Test for int16_t Macros    *********************************

//Macros for SRA test with Spike
#define SRA_TEST_S16_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    int16_t   op1; \
    uint8_t   op2; \
    int16_t   rslt_full; \
    int16_t   rslt_tb; \
    op1     = (int16_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (int16_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_S16_(&op1, &op2, &rslt_full); 

//Macros for SRA test without Spike
#define SRA_TEST_S16(mb,op1,op2,rslt_full,tn) \
    int16_t   op1; \
    uint8_t   op2; \
    int16_t   rslt_full; \
    op1     = (int16_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
	_SRA_TEST_S16_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//********************** SRA test for uint32_t Macros  **********************************

//Macros for SRA test with spike
#define SRA_TEST_U32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint32_t  op1;  \
    uint8_t   op2;  \
    uint32_t  rslt_full;  \
    uint32_t  rslt_tb; \
    op1     = (uint32_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint32_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U32_(&op1, &op2, &rslt_full);

//Macros for SRA test without spike
#define SRA_TEST_U32(mb,op1,op2,rslt_full,tn) \
    uint32_t  op1;  \
    uint8_t   op2;  \
    uint32_t  rslt_full;  \
    op1     = (uint32_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U32_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRA Test for int32_t Macros    *********************************

//Macros for SRA test with Spike
#define SRA_TEST_S32_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    int32_t   op1; \
    uint8_t   op2; \
    int32_t   rslt_full; \
    int32_t   rslt_tb; \
    op1     = (int32_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (int32_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_S32_(&op1, &op2, &rslt_full);


//Macros for SRA test without Spike
#define SRA_TEST_S32(mb,op1,op2,rslt_full,tn) \
    int32_t   op1; \
    uint8_t   op2; \
    int32_t   rslt_full; \
    op1     = (int32_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_S32_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//********************** SRA test for uint64_t Macros  **********************************

//Macros for SRAW test with Spike 
#define SRAW_TEST_U64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint64_t  op1;  \
    uint8_t   op2; \
    uint64_t  rslt_full; \
    uint64_t  rslt_tb; \
    op1     = (uint64_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint64_t)data[(tn-1)*3 + 2]; \
    _SRAW_TEST_U64_(&op1, &op2, &rslt_full);

//Macros for SRAW test without spike
#define SRAW_TEST_U64(mb,op1,op2,rslt_full,tn) \
    uint64_t  op1;  \
    uint8_t   op2;  \
    uint64_t  rslt_full;  \
    op1     = (uint64_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
    _SRAW_TEST_U64_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//******************   SRA Test for int64_t Macros    *********************************

//Macros for SRAW test with Spike
#define SRAW_TEST_S64_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    int64_t   op1; \
    uint8_t   op2; \
    int64_t   rslt_full; \
    int64_t   rslt_tb; \
    op1     = (int64_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (int64_t)data[(tn-1)*3 + 2]; \
    _SRAW_TEST_S64_(&op1, &op2, &rslt_full);


//Macros for SRA test without Spike
#define SRAW_TEST_S64(mb,op1,op2,rslt_full,tn) \
    int64_t   op1; \
    uint8_t   op2; \
    int64_t   rslt_full; \
    op1     = (int64_t)generate_random_num(mb); \
    op2     = (uint8_t)generate_random_num(mb); \
    _SRAW_TEST_S64_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;


/********************************************************************************************
//////////                  PART 3 : Assembly Compliance Test                 ///////////////
*********************************************************************************************/

//************   TEST_RR_SRC1_EQ_DEST Shift Right Arithmetic operation for uint8_t  *********

//Macro for SRA test without spike (assembly)
#define SRA_TEST_U8SRC1_EQ_DEST(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1; \
    uint8_t  op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
	_SRA_TEST_U8SRC1_EQ_DEST_(&op1,&op2,&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

//Macro for SRA test with spike (assembly)
#define SRA_TEST_U8SRC1_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1; \
    uint8_t   op2; \
	uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8SRC1_EQ_DEST_(&op1,&op2,&rslt_full);

//***********    TEST_RR_SRC2_EQ_DEST Shift Right Arithmetic Test for uint8_t    ***********

// Macro for SRA test without spike
#define SRA_TEST_U8SRC2_EQ_DEST(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1; \
    uint8_t  op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U8SRC2_EQ_DEST_(&op1,&op2,&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike
#define SRA_TEST_U8SRC2_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1; \
    uint8_t   op2; \
	uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8SRC2_EQ_DEST_(&op1,&op2,&rslt_full);

//***********  TEST_RR_SRC12_EQ_DEST Shift Right Arithmetic Test for uint8_t ******************

// Macro for SRA test without spike
#define SRA_TEST_U8SRC12_EQ_DEST(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1; \
    uint8_t  op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = op1; \
	_SRA_TEST_U8SRC12_EQ_DEST_(&op1,&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike
#define SRA_TEST_U8SRC12_EQ_DEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1; \
    uint8_t   op2; \
	uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8SRC12_EQ_DEST_(&op1,&rslt_full);

//***********    TEST_RR_ZEROSRC1 Shift Right Arithmetic Test for uint8_t      ***************

// Macro for SRA test without spike 
#define SRA_TEST_U8ZEROSRC1(mb,op1,op2,rslt_full,tn) \
    uint8_t   op1, op2; \
	uint8_t   rslt_full; \
    op1     = 0; \
    op2     = (uint8_t)generate_random_num(mb); \
	_SRA_TEST_U8ZEROSRC1_(&op2,&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8ZEROSRC1_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t op1, op2; \
	uint8_t rslt_full; \
    uint8_t rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8ZEROSRC1_(&op2,&rslt_full);

//**********  TEST_RR_ZEROSRC2 Shift Right Arithmetic Test for uint8_t         *********** 

// Macro for SRA test without spike
#define SRA_TEST_U8ZEROSRC2(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = 0; \
	_SRA_TEST_U8ZEROSRC2_(&op1,&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8ZEROSRC2_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
	uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8ZEROSRC2_(&op1,&rslt_full);

//**********     TEST_RR_ZEROSRC12 Shift Right Arithmetic Test for uint8_t      ***********

// Macro for SRA test without spike
#define SRA_TEST_U8ZEROSRC12(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
	uint8_t  rslt_full; \
    op1    = 0; \
    op2    = 0; \
    _SRA_TEST_U8ZEROSRC12_(&rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8ZEROSRC12_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
    uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8ZEROSRC12_(&rslt_full);

//**************      TEST_RR_ZERODEST Shift Right Arithmetic Test for uint8_t     ***********

// Macro for SRA test without spike  
#define SRA_TEST_U8ZERODEST(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
	uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U8ZERODEST_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8ZERODEST_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
    uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8ZERODEST_(&op1, &op2, &rslt_full);

//***************     TEST_RR_DEST_BYPASS Shift Right Arithmetic Test for uint8_t       **********
   
// Macro for SRA test without spike  
#define SRA_TEST_U8DEST_BYPASS(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
    uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8DEST_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
    uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8DEST_BYPASS_(&op1, &op2, &rslt_full);


//************     TEST_RR_SRC12_BYPASS Shift Right  Arithmetic Test for uint8_t     *********
  
// Macro for SRA test without spike
#define SRA_TEST_U8SRC12_BYPASS(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
    uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike  
#define SRA_TEST_U8SRC12_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
    uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8SRC12_BYPASS_(&op1, &op2, &rslt_full);
 

//********     TEST_RR_SRC21_BYPASS Shift Right Arithmetic Test for uint8_t     **********
    
// Macro for SRA test without spike 
#define SRA_TEST_U8SRC21_BYPASS(mb,op1,op2,rslt_full,tn) \
    uint8_t  op1, op2; \
    uint8_t  rslt_full; \
    op1    = (uint8_t)generate_random_num(mb); \
    op2    = (uint8_t)generate_random_num(mb); \
    _SRA_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full); \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = rslt_full;

// Macro for SRA test with spike 
#define SRA_TEST_U8SRC21_BYPASS_SPIKE(op1,op2,rslt_full,rslt_tb,tn)  \
    uint8_t   op1, op2; \
    uint8_t   rslt_full; \
    uint8_t   rslt_tb; \
    op1     = (uint8_t)data[(tn-1)*3 + 0]; \
    op2     = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb = (uint8_t)data[(tn-1)*3 + 2]; \
    _SRA_TEST_U8SRC21_BYPASS_(&op1, &op2, &rslt_full);


/*******************************************************************************************
///////////                     Min and Max Test using C Code                   ////////////
********************************************************************************************/

//******************        SRA Max Test for uint8_t integer            ********************

//Macro for SRA MAX Test for uint8_t with Spike
#define SRA_TEST_MAX_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int8_t)op1 >> op2;

//Macro for SRA MAX Test for uint8_t without Spike
#define SRA_TEST_MAX_U8_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int8_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Max Test for int8_t integer            ********************

//Macro for SRA MAX Test for int8_t with Spike
#define SRA_TEST_MAX_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MAX Test for int8_t without Spike
#define SRA_TEST_MAX_S8_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Max Test for uint16_t integer            ********************

//Macro for SRA MAX Test for uint16_t with Spike
#define SRA_TEST_MAX_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int16_t)op1 >> op2;

//Macro for SRA MAX Test for uint16_t without Spike
#define SRA_TEST_MAX_U16_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int16_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Max Test for int16_t integer            ********************

//Macro for SRA MAX Test for int16_t with Spike
#define SRA_TEST_MAX_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MAX Test for int16_t without Spike
#define SRA_TEST_MAX_S16_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Max Test for uint32_t integer            ********************

//Macro for SRA MAX Test for uint32_t with Spike
#define SRA_TEST_MAX_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int32_t)op1 >> op2;

//Macro for SRA MAX Test for uint32_t without Spike
#define SRA_TEST_MAX_U32_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int32_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Max Test for int32_t integer            ********************

//Macro for SRA MAX Test for int32_t with Spike
#define SRA_TEST_MAX_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MAX Test for int32_t without Spike
#define SRA_TEST_MAX_S32_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRAW Max Test for uint64_t integer            ********************

//Macro for SRAW MAX Test for uint64_t with Spike
#define SRAW_TEST_MAX_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int64_t)op1 >> op2;

//Macro for SRA MAX Test for uint64_t without Spike
#define SRAW_TEST_MAX_U64_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int64_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRAW Max Test for int64_t integer            ********************

//Macro for SRAW MAX Test for int64_t with Spike
#define SRAW_TEST_MAX_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRAW MAX Test for int64_t without Spike
#define SRAW_TEST_MAX_S64_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;


//**************************       MIN Test Macro    ***************************************
//******************        SRA Min Test for uint8_t integer            ********************

//Macro for SRA MIN Test for uint8_t with Spike
#define SRA_TEST_MIN_U8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int8_t)op1 >> op2;

//Macro for SRA MIN Test for uint8_t without Spike
#define SRA_TEST_MIN_U8_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int8_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for int8_t integer            ********************

//Macro for SRA MIN Test for int8_t with Spike
#define SRA_TEST_MIN_S8_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MIN Test for int8_t without Spike
#define SRA_TEST_MIN_S8_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for uint16_t integer            ********************

//Macro for SRA MIN Test for uint16_t with Spike
#define SRA_TEST_MIN_U16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int16_t)op1 >> op2;

//Macro for SRA MIN Test for uint16_t without Spike
#define SRA_TEST_MIN_U16_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int16_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for int16_t integer            ********************

//Macro for SRA MIN Test for int16_t with Spike
#define SRA_TEST_MIN_S16_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MIN Test for int16_t without Spike
#define SRA_TEST_MIN_S16_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for uint32_t integer            ********************

//Macro for SRA MIN Test for uint32_t with Spike
#define SRA_TEST_MIN_U32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int32_t)op1 >> op2;

//Macro for SRA MIN Test for uint32_t without Spike
#define SRA_TEST_MIN_U32_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int32_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for int32_t integer            ********************

//Macro for SRA MIN Test for int32_t with Spike
#define SRA_TEST_MIN_S32_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MIN Test for int32_t without Spike
#define SRA_TEST_MIN_S32_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for uint64_t integer            ********************

//Macro for SRA MIN Test for uint64_t with Spike
#define SRA_TEST_MIN_U64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = (int64_t)op1 >> op2;

//Macro for SRA MIN Test for uint64_t without Spike
#define SRA_TEST_MIN_U64_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = (int64_t)op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;

//******************        SRA Min Test for int64_t integer            ********************

//Macro for SRA MIN Test for int64_t with Spike
#define SRA_TEST_MIN_S64_SPIKE_C(op1,op2,rslt_full,rslt_tb,tn,op1_dt,res_dt)  \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    res_dt      rslt_tb; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
    rslt_tb   = (res_dt)data[(tn-1)*3 + 2]; \
    rslt_full = op1 >> op2;

//Macro for SRA MIN Test for int64_t without Spike
#define SRA_TEST_MIN_S64_C(mb,op1,op2,rslt_full,tn,op1_dt,res_dt,op1_val,op2_val) \
    op1_dt      op1; \
    uint8_t     op2; \
    res_dt      rslt_full; \
    op1       = op1_val; \
    op2       = op2_val ; \
    rslt_full = op1 >> op2; \
    actual_result[(tn-1)*3 + 0 ] = op1; \
    actual_result[(tn-1)*3 + 1 ] = op2; \
    actual_result[(tn-1)*3 + 2 ] = rslt_full;


/*******************************************************************************************
 ***************     Macro for Immediate Shift Right Arithmetic Instruction   **************
 *******************************************************************************************/

//****************************  SRAI Macro ***************************************
#define TEST_SRAI_INSN_I(mb,insn,op1,imm,result,tn,op1_dt,res_dt) \
    op1_dt    op1; \
    uint8_t   op2; \
	res_dt    result; \
    op1     = (op1_dt)generate_random_num(mb); \
    op2     = imm; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SRAI_INSN_I_SPIKE(insn,op1,imm,result,exp_result,tn,op1_dt,res_dt) \
    op1_dt     op1; \
    uint8_t    op2; \
	res_dt     result; \
	res_dt     exp_result; \
    op1      = (op1_dt)data[(tn-1)*3 + 0]; \
    op2      = (uint8_t)data[(tn-1)*3 + 1]; \
	result   = (res_dt)data[(tn-1)*3 + 2]; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (exp_result) : [x] "r" (op1) ) ; \

//***********************   SRAIW Macro  ***************************************************
#define TEST_SRAIW_INSN_I(mb,insn,op1,imm,result,tn,op1_dt,res_dt) \
    op1_dt   op1; \
    uint8_t  op2; \
	res_dt   result; \
    op1    = (op1_dt)generate_random_num(mb); \
    op2    = imm; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = result;


// Macros for I-Type instruction test (SPIKE) 
#define TEST_SRAIW_INSN_I_SPIKE(insn,op1,imm,result,exp_result,tn,op1_dt,res_dt) \
    op1_dt      op1; \
    uint8_t     op2; \
	res_dt      result; \
	res_dt      exp_result; \
    op1        =(op1_dt) data[(tn-1)*3 + 0]; \
    op2        =(uint8_t) data[(tn-1)*3 + 1]; \
	result     =(res_dt) data[(tn-1)*3 + 2]; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (exp_result) : [x] "r" (op1) ) ; \



/***********************************************************************************************************************
 *************                          MACRO for SRA/SRAW- Immediate                           ************************
 *************                                                                                  ************************
 ***********************************************************************************************************************/

//****************           Min and Max Case for SRAI/SRAIW Instruction               *******************************

//*************************   SRAIW           *************************************************
#define TEST_MAX_MIN_SRAIW_INSN_I(insn,op1,op2,result,tn,op1_dt,res_dt,op1_val,imm) \
    op1_dt    op1; \
    uint8_t   op2; \
	res_dt    result; \
    op1     = (op1_dt)op1_val; \
    op2     = imm; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = result;

// Macros for I-Type instruction test (SPIKE) 
#define TEST_MAX_MIN_SRAIW_INSN_I_SPIKE(insn,op1,op2,result,exp_result,tn,op1_dt,res_dt) \
    op1_dt      op1; \
    uint8_t     op2; \
	res_dt      result; \
	res_dt      exp_result; \
    op1       = (op1_dt) data[(tn-1)*3 + 0]; \
    op2       = (uint8_t) data[(tn-1)*3 + 1]; \
	result    = (res_dt) data[(tn-1)*3 + 2]; \
	asm volatile (sraw_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ; 

//***************************    SRAI   *************************************************
// Macros for SRAI without SPIKE
#define TEST_MAX_MIN_SRAI_INSN_I(insn,op1,op2,result,tn,op1_dt,res_dt,op1_val,imm) \
    op1_dt   op1; \
    uint8_t  op2; \
	res_dt   result; \
    op1    = (op1_dt)op1_val; \
    op2    = imm; \
	asm volatile (#insn "    %[z], %[x], " #imm "\n\t"  : [z] "=r" (result) : [x] "r" (op1) ) ; \
    actual_result[(tn-1)*3 + 0] = op1; \
    actual_result[(tn-1)*3 + 1] = op2; \
    actual_result[(tn-1)*3 + 2] = result;

// Macros for SRAI with SPIKE 
#define TEST_MAX_MIN_SRAI_INSN_I_SPIKE(insn,op1,op2,result,exp_result,tn,op1_dt,res_dt) \
    op1_dt      op1; \
    uint8_t     op2; \
	res_dt      result; \
	res_dt      exp_result; \
    op1       = (op1_dt)data[(tn-1)*3 + 0]; \
    op2       = (uint8_t)data[(tn-1)*3 + 1]; \
	result    = (res_dt)data[(tn-1)*3 + 2]; \
	asm volatile (sra_test : [z] "=r" (exp_result) : [x] "r" (op1) , [y] "r" (op2) ) ;

	

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for load and store without spike
#define TEST_LOAD_STORE_INSN_I( mb, insn1 , insn2  , imm, result, tn  ,op1_dt , res_dt) \
		        op1_dt op1 ; \
				uint64_t op2; \
                int16_t op3; \
	            res_dt result; \
			    op1 = (op1_dt)generate_random_num(mb); \
                op2 = addrs_pt; \
                op3 = imm; \
				op1_dt mem_data ;\
            	asm volatile ("mv  a4  , %[x]  \n\t" :  : [x] "r" (op2)  ) ; \
            	asm volatile ("mv  a3  , %[x]  \n\t" :  : [x] "r" (op1)  ) ; \
            	asm volatile (#insn2 " a5 ,  " #imm "(a4)"  ) ; \
		        asm volatile (#insn1 " a3 ,  " #imm "(a4)"  ) ; \
				asm volatile (#insn2 " a2 ,  " #imm "(a4)"  ) ; \
				asm volatile (#insn1 " a5 ,  " #imm "(a4)"  ) ; \
            	asm volatile ("mv  %[x] , a2 "  : [x] "=r" (result) :  ) ; \
                actual_result[(tn-1)*3 + 0] = op1; \
                actual_result[(tn-1)*3 + 1] = op3; \
                actual_result[(tn-1)*3 + 2] = result; 
				
// Macros for load and store spike
#define TEST_LOAD_STORE_INSN_I_SPIKE(insn1 , insn2, op1, op2 , op3 ,imm, result, exp_result, tn , op1_dt, res_dt) \
		        op1_dt op1;\
				uint64_t op2;\
                int16_t op3;\
	            res_dt result;\
	        	res_dt exp_result; \
                op1        = (op1_dt) data[(tn-1)*3 + 0]; \
				op2		   = addrs_pt ; \
                op3        = imm ; \
				op1_dt mem_data ; \
            	asm volatile ("mv  a4  , %[x]  \n\t" :  : [x] "r" (op2)  ) ; \
            	asm volatile ("mv  a3  , %[x]  \n\t" :  : [x] "r" (op1)  ) ; \
            	asm volatile (#insn2 " a5 ,  " #imm "(a4)"  ) ; \
		        asm volatile (#insn1 " a3 ,  " #imm "(a4)"  ) ; \
				asm volatile (#insn2 " a2 ,  " #imm "(a4)"  ) ; \
				asm volatile (#insn1 " a5 ,  " #imm "(a4)"  ) ; \
            	asm volatile ("mv  %[x] , a2 "  :   [x] "=r" (exp_result) : ) ; \
                result     = (res_dt)data[(tn-1)*3 + 2]; 

//macro print load and store unsigned
#define PRINT_LOAD_STORE_TEST_RESULT_IU(testnumber, op1, op2, op3 , result, exp_result)\
            if((result == exp_result) && (result == op1 ) ) \
                printf ("Test  [%3d]   Store = %15u to   [%#010X  + 12'd%10d ] load: E res = %15u , A res = %15u : Status = [PASS]\n", testnumber,op1,op2,op3,exp_result,result);\
                else \
                printf ("Test  [%3d]   Store = %15u to   [%#010X  + 12'd%10d ] load: E res = %15u , A res = %15u : Status = [FAIL]\n", testnumber,op1,op2,op3,exp_result ,result);\
                
//macro print load and store signed 
#define PRINT_LOAD_STORE_TEST_RESULT_IS(testnumber, op1, op2, op3 , result, exp_result)\
            if( (result == exp_result) && (result == op1 )) \
                printf ("Test  [%3d]   Store = %15ld to   [%#010X  + 12'd%10ld ] load: E res = %15ld , A res = %15ld : Status = [PASS]\n", testnumber,op1,op2,op3,exp_result,result);\
                else \
                printf ("Test  [%3d]   Store = %15ld to   [%#010X  + 12'd%10ld ] load: E res = %15ld , A res = %15ld : Status = [FAIL]\n", testnumber,op1,op2,op3,exp_result ,result);\
    



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////Macro for LUI Test Cases ////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Macro for lui without spike
#define TEST_LUI_INSN_I(  insn  , imm, result, tn  ,op1_dt , res_dt) \
		        op1_dt op1 ; \
	            res_dt result; \
                op1 = imm; \
				asm volatile (#insn " %[z]," #imm "\n\t" : [z] "=r" (result) :  ) ;\
                actual_result[(tn-1)*3 + 0] = op1;\
                actual_result[(tn-1)*3 + 1] = result;\
                actual_result[(tn-1)*3 + 2] = 0; 
				

// Macros for lui spike
#define TEST_LUI_INSN_I_SPIKE(insn , op1 ,imm, result, exp_result, tn , op1_dt, res_dt) \
                op1_dt op1;\
	            res_dt result , exp_result; \
				asm volatile (#insn " %[z]," #imm "\n\t" : [z] "=r" (exp_result) :  ) ; \
                op1    = data[(tn-1)*3 + 0] ;\
                result = (res_dt)data[(tn-1)*3 + 1]; 



/*********************************Branch and Jump test cases***************************/
#define RAND_ARR_SORT(mb,tn)\
                      int64_t rand_arr[10];\
					  int64_t *p=rand_arr;\
					  for ( int64_t i = 0;i<10;i++)\
					  {    rand_arr[i] = (int64_t)generate_random_num(mb);\
                           actual_result[(tn-1)*20 + i] = rand_arr[i];}\

#define RAND_ARR_SEARCH(mb,tn)\
                      int64_t rand_arr[10];\
					  int64_t *p=rand_arr;\
					  for ( int64_t i = 0;i<10;i++)\
					  {    rand_arr[i] = (int64_t)generate_random_num(mb);\
                           actual_result[(tn-1)*11 + i] = rand_arr[i];}\


/*************************************Selection Sort**********************************/


#define SELECTION_SORT_TEST_C(mb,rand_arr,rslt_full,tn)\
                      int64_t rslt_full[10];\
                      int64_t i,j,index,temp;\
                      int64_t size_1;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      for( i=0;i<size_1-1;i++)\
                      {  index=i;\
                      for(j=i+1;j<size_1;j++)\
                      {  if(rand_arr[j]<rand_arr[index])\
                         index=j;\
                      }\
                      temp = rand_arr[i];\
                      rand_arr[i] = rand_arr[index];\
                      rand_arr[index] = temp;\
                      }\
                      for( i=0;i<size_1;i++)\
                      { rslt_full[i] = rand_arr[i];\
                      }\
                      for( i=0;i<size_1;i++)\
                      { actual_result[(tn-1)*20 +(10+i)] = rslt_full[i]; }\

#define SELECTION_SORT_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full[10]; \
                      int64_t rslt_tb[10];\
                      int64_t i,j,index,temp;\
                      int64_t size_1;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rslt_tb[i] = (int64_t)data[(tn-1)*20 + (10+i)]; }\
                      for( i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*20 + i]; \
                      }\
                      for(  i=0;i<size_1-1;i++)\
                      {  index=i;\
                      for(j=i+1;j<size_1;j++)\
                      { if(e_rand_arr[j]< e_rand_arr[index])\
                        index=j;\
                      }\
                      temp = e_rand_arr[i];\
                      e_rand_arr[i] = e_rand_arr[index];\
                      e_rand_arr[index] = temp;  }\
                      for( i=0;i<size_1;i++)\
                      { rslt_full[i] = e_rand_arr[i];  } 


/*************************************Insertion Sort**********************************/

                                                           
#define INSERTION_SORT_TEST_C(mb,rand_arr,rslt_full ,tn)\
                      int64_t rslt_full[10];\
                      int64_t i,j,key;\
                      int64_t size_1;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      for(i=1;i<size_1;i++)\
                      {  key = rand_arr[i];\
                             j=i-1;\
                      while( j>=0 && rand_arr[j]>key)\
                      { rand_arr[j+1] = rand_arr[j];\
                           j=j-1;\
                      }\
                     rand_arr[j+1]=key; }\
                     for( i=0;i<size_1;i++)\
                     { rslt_full[i] = rand_arr[i];\
                     }\
                      for( i=0;i<size_1;i++)\
                      { actual_result[(tn-1)*20 +(10+i)] = rslt_full[i]; }\

#define INSERTION_SORT_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full[10]; \
                      int64_t rslt_tb[10];\
                      int64_t i,j,key;\
                      int64_t size_1;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rslt_tb[i] = (int64_t)data[(tn-1)*20 + (10+i)]; }\
                      for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*20 + i]; \
                      }\
                      for(i=1;i<size_1;i++)\
                      {  key = e_rand_arr[i];\
                             j=i-1;\
                      while( j>=0 && e_rand_arr[j]>key)\
                      { e_rand_arr[j+1] = e_rand_arr[j];\
                           j=j-1;\
                      }\
                     e_rand_arr[j+1]=key; }\
                     for( i=0;i<size_1;i++)\
                     { rslt_full[i] = e_rand_arr[i];  }\ 


/*************************************Bubble Sort**********************************/

#define BUBBLE_SORT_TEST_C(mb,rand_arr,rslt_full ,tn)\
                      int64_t rslt_full[10];\
                      int64_t i,j,temp;\
                      int64_t size_1;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for(i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(rand_arr[i]>rand_arr[j])\
                          { temp = rand_arr[i];\
                            rand_arr[i] = rand_arr[j];\
                          rand_arr[j] = temp; } } }\
                      for( i=0;i<size_1;i++)\
                      { rslt_full[i] = rand_arr[i];\
                      }\
                      for( i=0;i<size_1;i++)\
                      { actual_result[(tn-1)*20 +(10+i)] = rslt_full[i]; }\
                                    
                     
#define BUBBLE_SORT_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full[10]; \
                      int64_t rslt_tb[10];\
                      int64_t i,j,temp;\
                      int64_t size_1;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rslt_tb[i] = (int64_t)data[(tn-1)*20 + (10+i)]; }\
                      for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*20 + i]; \
                      }\
                      for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(e_rand_arr[i] > e_rand_arr[j])\
                          { temp = e_rand_arr[i];\
                            e_rand_arr[i] = e_rand_arr[j];\
                          e_rand_arr[j] = temp; } }  }\
                     for( i=0;i<size_1;i++)\
                     { rslt_full[i] = e_rand_arr[i];  }\


/*************************************Shell Sort**********************************/

#define SHELL_SORT_TEST_C(mb,rand_arr,rslt_full ,tn)\
                      int64_t rslt_full[10];\
                      int64_t i,j,gap,key;\
                      int64_t size_1;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for(i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      for(gap =size_1/2;gap>0;gap/=2)\
                      { for(i=0;i<size_1;i++)\
                      {  j=i-gap;\
                         key= rand_arr[i];\
                      while(j>=0 && rand_arr[j]>key)\
                      { rand_arr[j+gap] = rand_arr[j];\
                      j=j-gap; }\
                      rand_arr[j+gap] = key; } }\
                      for( i=0;i<size_1;i++)\
                      { rslt_full[i] = rand_arr[i];\
                      }\
                      for( i=0;i<size_1;i++)\
                      { actual_result[(tn-1)*20 +(10+i)] = rslt_full[i]; }\
                                    
                     
#define SHELL_SORT_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full[10]; \
                      int64_t rslt_tb[10];\
                      int64_t i,j,key,gap;\
                      int64_t size_1;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rslt_tb[i] = (int64_t)data[(tn-1)*20 + (10+i)]; }\
                      for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*20 + i]; \
                      }\
                      for(gap =size_1/2;gap>0;gap/=2)\
                      { for(i=0;i<size_1;i++)\
                      {  j=i-gap;\
                         key= e_rand_arr[i];\
                      while(j>=0 && e_rand_arr[j]>key)\
                      { e_rand_arr[j+gap] = e_rand_arr[j];\
                      j=j-gap; }\
                      e_rand_arr[j+gap] = key; } }\
                      for( i=0;i<size_1;i++)\
                     { rslt_full[i] = e_rand_arr[i];  }\ 


/************************************Gnome Sort ***********************************/

#define GNOME_SORT_TEST_C(mb,rand_arr,rslt_full ,tn)\
                      int64_t rslt_full[10];\
                      int64_t i,index;\
                      int64_t size_1,temp;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for(i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      while (index < size_1)\
                      { if (index == 0)\
                         index++;\
                         if (rand_arr[index] >= rand_arr[index - 1])\
                            index++;\
                      else \
                      {  temp = rand_arr[index];\
                         rand_arr[index] = rand_arr[index-1];\
                         rand_arr[index-1] = temp;\
                         index--; }}\
                      for( i=0;i<size_1;i++)\
                      { rslt_full[i] = rand_arr[i];\
                      }\
                      for( i=0;i<size_1;i++)\
                      { actual_result[(tn-1)*20 +(10+i)] = rslt_full[i]; }\
                                    
                     
#define GNOME_SORT_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full[10]; \
                      int64_t rslt_tb[10];\
                      int64_t i,index;\
                      int64_t size_1,temp;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      for( i=0;i<size_1;i++)\
                      {  rslt_tb[i] = (int64_t)data[(tn-1)*20 + (10+i)]; }\
                      for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*20 + i]; \
                      }\
                      while (index < size_1)\
                      { if (index == 0)\
                         index++;\
                      if (e_rand_arr[index] >= e_rand_arr[index - 1])\
                            index++;\
                      else \
                      {  temp = e_rand_arr[index];\
                         e_rand_arr[index] = e_rand_arr[index-1];\
                         e_rand_arr[index-1] = temp;\
                         index--; }}\
                      for( i=0;i<size_1;i++)\
                     { rslt_full[i] = e_rand_arr[i];  }\ 


/************************************** Linear Search ***************************************/

#define LINEAR_SEARCH_TEST_C(mb,rand_arr,rslt_full ,tn)\
                      int64_t rslt_full;\
                      int64_t i,j,temp;\
                      int64_t size_1,x;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for(i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                      for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(rand_arr[i]>rand_arr[j])\
                          { temp = rand_arr[i];\
                            rand_arr[i] = rand_arr[j];\
                          rand_arr[j] = temp; } } }\
                      x=rand_arr[4];\
                      for(i=0;i<size_1;i++)\
                      { if(rand_arr[i]==x)\
                          rslt_full = i;}\
                      actual_result[(tn-1)*11 + 10] = rslt_full;
               
      
                     
#define LINEAR_SEARCH_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full; \
                      int64_t rslt_tb;\
                      int64_t i,j,x;\
                      int64_t size_1,temp;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      rslt_tb = (int64_t)data[(tn-1)*11 + 10];\
                       for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*11 + i]; \
                      }\
                      for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(e_rand_arr[i]>e_rand_arr[j])\
                          { temp = e_rand_arr[i];\
                            e_rand_arr[i] = e_rand_arr[j];\
                          e_rand_arr[j] = temp; } } }\
                        x=e_rand_arr[4];\
                      for(i=0;i<size_1;i++)\
                     { if(e_rand_arr[i]==x)\
                       rslt_full = i; }\


/************************************* Binary Search ***********************************/
#define BINARY_SEARCH_TEST_C(mb,rand_arr,rslt_full ,tn)\
                         int64_t rslt_full;\
                      int64_t i,j,temp;\
                      int64_t size_1,x;\
                      int64_t low,high,mid;\
                      size_1 = sizeof(rand_arr)/sizeof(rand_arr[0]);\
                      for(i=0;i<size_1;i++)\
                      {  rand_arr[i] = (int64_t)(*p);\
                         p++; }\
                     for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(rand_arr[i]>rand_arr[j])\
                          { temp = rand_arr[i];\
                            rand_arr[i] = rand_arr[j];\
                          rand_arr[j] = temp; } } }\
                      x=rand_arr[5];\
                      low= 0;\
                      high= size_1-1;\
                      while(low<high) {\
                     mid= low +((high-low)/2);\
                      if(rand_arr[mid]==x)\
                          { rslt_full = mid ;\
                              break; }\
                    if(rand_arr[mid]>x)\
                     high = mid-1;\
                     else \
                     low = mid+1; }\
                     actual_result[(tn-1)*11 + 10] = rslt_full;


       
                     
#define BINARY_SEARCH_TEST_SPIKE_C(e_rand_arr,rslt_full,rslt_tb,tn)\
                      int64_t e_rand_arr[10]; \
                      int64_t rslt_full; \
                      int64_t rslt_tb;\
                      int64_t i,j,x;\
                      int64_t size_1,temp;\
                      int64_t low,mid,high;\
                      size_1 = sizeof(e_rand_arr)/sizeof(e_rand_arr[0]);\
                      rslt_tb = (int64_t)data[(tn-1)*11 + 10]; \
                      for(i=0;i<size_1;i++)\
                      { e_rand_arr[i] = (int64_t)data[(tn-1)*11 + i]; \
                      }\
                      for(i=0;i<size_1-1;i++)\
                      { for(j=i+1;j<size_1;j++)\
                      { if(e_rand_arr[i]>e_rand_arr[j])\
                          { temp = e_rand_arr[i];\
                            e_rand_arr[i] = e_rand_arr[j];\
                          e_rand_arr[j] = temp; } } }\
                        x = e_rand_arr[5];\
                         low = 0;\
                      high = size_1-1;\
                      while(low<=high) {\
                     mid= low +((high-low)/2);\
                      if(e_rand_arr[mid]==x)\
                          {  rslt_full = mid ;\
                              break ; }\
                      if(e_rand_arr[mid]>x)\
                     high = mid-1;\
                     else \
                     low = mid+1; }\
  

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////Macro for AUIPC Test Cases ////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Macro for auipc without spike
#define TEST_AUIPC_INSN_I(  insn  , imm, result, tn  ,op1_dt , res_dt) \
		        op1_dt op1 ; \
	            res_dt result; \
                op1 = imm; \
				asm volatile (#insn " %[z]," #imm "\n\t" : [z] "=r" (result) :  ) ;\
                actual_result[(tn-1)*3 + 0] = op1;\
                actual_result[(tn-1)*3 + 1] = result;\
                actual_result[(tn-1)*3 + 2] = 0; 
				
#define TEST_AUIPC_JALR_INSN_I(  insn1, insn2  , imm1 ,imm2 , result, tn  ,op1_dt , res_dt) \
		        op1_dt op1 ; \
	            res_dt result; \
                op1 = imm1; \
                asm volatile (#insn1 " %[z]," #imm1 "\n\t" : [z] "=r" (result) :  ) ;\
                asm volatile (#insn2 "    %[z], %[x], " #imm2 "\n\t"  : [z] "=r" (op1) : [x] "r" (result) ) ; \
                actual_result[(tn-1)*3 + 0] = op1;\
                actual_result[(tn-1)*3 + 1] = result;\
                actual_result[(tn-1)*3 + 2] = 0; 
		
#define TEST_JALR_AUIPC_INSN_I(  insn1, insn2  , imm2, imm1, result, tn  ,op1_dt , res_dt) \
		        op1_dt op1 ; \
	            res_dt result; \
                op1 = imm1; \
                asm volatile (#insn1 "    %[z], %[x], " #imm2 "\n\t"  : [z] "=r" (op1) : [x] "r" (result) ) ; \
                asm volatile (#insn2 " %[z]," #imm1 "\n\t" : [z] "=r" (result) :  ) ;\
                actual_result[(tn-1)*3 + 0] = op1;\
                actual_result[(tn-1)*3 + 1] = result;\
                actual_result[(tn-1)*3 + 2] = 0; 
				


                                                               

#endif // TESTMACRO_H 


